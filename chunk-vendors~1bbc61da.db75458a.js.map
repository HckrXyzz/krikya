{"version":3,"sources":["webpack:///./node_modules/@egjs/flicking/dist/flicking.esm.js"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","pop","push","__values","o","m","__read","r","ar","error","__spread","concat","STATE_TYPE","CODE","WRONG_TYPE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","NOT_ATTACHED_TO_FLICKING","WRONG_OPTION","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","NOT_ALLOWED_IN_VIRTUAL","MESSAGE","wrongVal","correctTypes","map","type","join","selector","val","name","optionName","min","max","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","PANEL_CHANGE","ALIGN","PREV","CENTER","NEXT","DIRECTION","NONE","MOVE_TYPE","SNAP","FREE_SCROLL","STRICT","CLASS","VERTICAL","HIDDEN","DEFAULT_VIRTUAL","CIRCULAR_FALLBACK","LINEAR","BOUND","getElement","el","parent","targetEl","isString","parentEl","document","queryResult","querySelector","FlickingError","nodeType","Node","ELEMENT_NODE","checkExistence","nameOnErrMsg","clamp","x","Math","getFlickingAttached","toArray","iterable","slice","parseAlign$1","align","size","alignPoint","parseArithmeticSize","parseBounce","bounce","parsedBounce","isArray","parsedVal","cssValue","base","parsed","parseArithmeticExpression","percentage","absolute","cssRegex","idx","matchResult","exec","sign","unit","parsedValue","parseFloat","signMultiplier","parsePanelAlign","panel","getDirection","start","end","parseElement","element","elements","forEach","tempDiv","createElement","innerHTML","children","firstChild","removeChild","getMinusCompensatedIndex","includes","array","target","e_1","_a","array_1","array_1_1","e_1_1","return","circulatePosition","pos","offset","find","checker","e_2","array_2","array_2_1","e_2_1","findIndex","getProgress","prev","getStyle","window","getComputedStyle","currentStyle","setSize","width","height","style","isBetween","circulateIndex","index","range","arr","obj","proto","_super","message","code","_this","Error","Viewport","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","__proto","defineProperty","get","enumerable","configurable","padding","isBorderBoxSizing","newWidth","newHeight","resize","elStyle","clientWidth","clientHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","AutoResizer","flicking","_onResize","_flicking","_skipFirstResize","isFirstResize","_enabled","_resizeObserver","enable","viewport","disable","useResizeObserver","ResizeObserver","viewportSizeNot0","resizeObserver","observe","addEventListener","disconnect","removeEventListener","VanillaElementProvider","_element","_rendered","show","cameraEl","camera","parentElement","appendChild","hide","VirtualElementProvider","_virtualElement","nativeElement","visible","elIndex","_panel","elementIndex","virtualElements","virtual","init","VirtualManager","options","_b","_c","_d","_renderPanel","renderPanel","_initialPanelCount","initialPanelCount","_cache","cache","_panelClass","panelClass","_elements","set","renderer","panels","uncacheRenderResult","virtualEnabled","externalRenderer","renderExternal","_initVirtualElements","nativeEl","display","append","count","insert","prepend","batchInsert","hasDOMInElements","remove","batchRemove","deleteCount","cameraElement","panelsPerView","fragment","createDocumentFragment","newElements","panelEl","className","dataset","toString","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","State","_delta","_targetPanel","onEnter","prevState","onHold","ctx","onChange","onRelease","onAnimationEnd","onFinish","_moveToChangedPosition","axesEvent","transitTo","delta","prevPosition","newPosition","circularEnabled","lookAt","moveEvent","isTrusted","holding","direction","trigger","isCanceled","DISABLED","IdleState","animating","panelCount","holdStartEvent","HOLDING","controller","control","animatingContext","moveStartEvent","ANIMATING","HoldingState","_releaseEvent","inputEvent","horizontal","offsetX","offsetY","DRAGGING","flick","setTo","IDLE","clickedElement","releaseEvent","srcEvent","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","panels_1","panels_1_1","contains","cameraPosition","clickedPanelPosition","DraggingState","destPos","duration","moveToPosition","AnimatingState","updateInput","setActive","activePanel","DisabledState","stop","StateMachine","nextStateType","nextState","_state","fire","eventType","externalCtx","currentState","AxesController","_onAxesHold","_dragged","_onAxesChange","_preventClickWhenDragged","preventDefault","stopPropagation","_resetInternalValues","_stateMachine","_axes","state","_animatingContext","axes","circular","axis","_panInput","isEnable","deceleration","interruptable","easing","inputType","iOSEdgeSwipeThreshold","scale","releaseOnScroll","connect","_loop_1","key","on","destroy","removePreventClickHandler","update","controlParams","axm","addPreventClickHandler","off","animateTo","startPos","targetPanel","animate","resetContext","once","newPos","animationFinishHandler","interruptionHandler","Control","_controller","_activePanel","updatePosition","_progressInPanel","clampToReachablePosition","resetActive","moveToPanel","nearestAnchor","camPos_1","camRangeDiff","possiblePositions","findNearestAnchor","removed","canReach","rangeDiff","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","newActivePanel","prevActivePanel","updateAdaptiveHeight","prevIndex","prevPanel","triggeringEvent","event","render","catch","err","AnchorPoint","_index","_pos","SnapControl","_count","activeAnchor","anchorAtCamera","snapThreshold","posDelta","absPosDelta","snapDelta","targetAnchor","findActiveAnchor","_calcSnapThreshold","_findSnappedAnchor","threshold","_findAdjacentAnchor","currentPos","clampedPosition","anchorAtPosition","findAnchorIncludePosition","isFinite","anchors","anchorPoints","loopCount","floor","circularIndexOffset","anchorAtPositionIndex","anchor","loop","adjacentAnchor","getNextAnchor","getPrevAnchor","isNextDirection","panelSize","alignPos","alignPosition","margin","FreeControl","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","targetPos","StrictControl","_resetIndexRange","cameraRange","currentIndex","prevPanelIndex","nextPanelIndex","nextPanel","prevPos","nextPos","_indexRange","axesRange","indexRange","isOverThreshold","firstAnchor","lastAnchor","shouldBounceToFirst","shouldBounceToLast","CameraMode","getAnchors","anchorsIncludingPosition","includePosition","nearest","getCircularOffset","panelPos","canSee","visibleRange","isVisibleOnRange","LinearCameraMode","checkAvailability","getRange","firstPanel","getPanel","lastPanel","CircularCameraMode","firstPanelPrev","lastPanelNext","visibleSize","panelSizeSum","canSetCircularMode","every","anchorCount","positionInRange","anchorInRange","possibleAnchors","toggled","toggledPrev","toggleDirection","toggledNext","_calcPanelAreaSum","visibleInCurrentRange","sum","sizeIncludingMargin","BoundCameraMode","viewportSize","panelAreaSize","isBiggerThanViewport","firstPos","lastPos","alignVal","reachablePanels","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","newAnchors","splice","nearestPanelAtMin","_findNearestPanel","panelAtMin","panelAtMax","prevDist","panelIdx","dist","Camera","_checkTranslateSupport","transforms","supportedStyle","documentElement","transformName","transforms_1","transforms_1_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_circularOffset","_circularEnabled","_mode","_range","_visiblePanels","_anchors","NaN","nearestPanel","bounceSize","prevRange","nextRange","nextPosition","viewportEl","firstElementChild","_updateMode","_togglePanels","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","applyTransform","updateOffset","getProgressInPanel","anchorIdx","activeIndex","updateRange","updateCircularToggleDirection","updateAlignPos","updateAnchors","adaptive","unRenderedPanels","rendered","resetNeedPanelHistory","_needPanelTriggered","actualPosition","newVisiblePanels","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","needPanelThreshold","cameraPrev","cameraNext","wasBetweenRange","isBetweenRange","circularMode","fallbackMode","circularFallback","bound","toggle","some","isToggled","Renderer","strategy","_panels","_strategy","panelAlign","_collectPanels","forceRenderAllPanels","markForShow","updatePanelSize","_updatePanelSizeByGrid","items","_i","prevFirstPanel","allPanelsInserted","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","_insertPanelElements","increaseIndex","_updateCameraAndControl","checkPanelContentsReady","allPanelsRemoved","removingIdx","panelsPulled","panelsRemoved","decreaseIndex","_removePanelElements","checkingPanels","resizeOnContentsReady","hasContents","contentsReadyChecker","loading","prevProgressInPanel","panelBehind","initialized","readyCount","totalCount","check","_showOnlyVisiblePanels","visibleIndexes","visibles","markForHide","referencePanel","gap","panelSizeObj","firstPanelSizeObj","noPanelStyleOverride","updatePanelSizes","_removeAllChildsFromCamera","nextSibling","nextSiblingElement","insertBefore","VanillaRenderer","updateRenderingPanels","renderPanels","_resetPanelElementOrder","_removeAllTextNodes","collectPanels","createPanel","reversedElements","getRenderingElementsByOrder","reverse","nextEl","nextElementSibling","childNodes","node","TEXT_NODE","ExternalRenderer","Panel","elementProvider","_elProvider","_removed","_loading","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","camPos","disappearPosNext","disappearPosPrev","checkingRange","cached","offsetWidth","offsetHeight","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","includeRange","focus","moveTo","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","NormalRenderingStrategy","providerCtor","_providerCtor","getRenderingIndexesByOrder","renderedPanels","notToggled","renderOnlyVisible","VirtualPanel","_cachedInnerHTML","virtualElCount","cacheRenderResult","newInnerHTML","VirtualRenderingStrategy","virtualManager","invisibleIndexes","sort","panel1","panel2","Flicking","root","defaultIndex","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","preventEventsBeforeInit","_q","_r","_s","pow","_t","_u","moveType","_v","_w","_x","_y","_z","preventClickOnDrag","_0","disableOnInit","_1","_2","_3","autoInit","_4","autoResize","_5","_6","_7","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_circularFallback","_bound","_adaptive","_panelsPerView","_noPanelStyleOverride","_resizeOnContentsReady","_virtual","_needPanelThreshold","_preventEventsBeforeInit","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoInit","_autoResize","_useResizeObserver","_externalRenderer","_renderExternal","_viewport","_autoResizer","_renderer","_createRenderer","_camera","_createCamera","_control","_createControl","_virtualManager","prevVal","originalTrigger","_moveToInitialPanel","disableInput","plugin","enableInput","getStatus","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","visibleOffset","setStatus","panelIndex","newCameraPos","addPlugins","plugins","removePlugins","foundIndex","prevWidth","prevHeight","sizeChanged","moveTypes","keys","moveTypeStr","moveTypeOptions","JSON","stringify","console","warn","_createExternalRenderer","_createVanillaRenderer","rendererOptions","initialPanel","VERSION","withFlickingMethods","flickingName","getOwnPropertyNames","startsWith","descriptor","getOwnPropertyDescriptor","args","getterDescriptor","sync","diffResult","prevList","endIdx_1","prevIdx_1","removedIdx","ordered","prevIdx","newIdx","indexDiff","middlePanels","startIdx_1","prevIdx_2","addedElements_1","addedIdx","addedElements","startIdx","endIdx","elIdx","getRenderingPanels","removedPanels","maintainedMap","maintained","current","list","getDefaultCameraTransform","firstPanelSize","cameraAlign","getCameraAlign","getPanelAlign","camPosition","parseAlign"],"mappings":"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","file":"js/chunk-vendors~1bbc61da.db75458a.js","sourcesContent":["/*\nCopyright (c) 2015-present NAVER Corp.\nname: @egjs/flicking\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-flicking\nversion: 4.5.0\n*/\nimport Component, { ComponentEvent } from '@egjs/component';\nimport Axes, { PanInput } from '@egjs/axes';\nimport ImReady from '@egjs/imready';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n/** @deprecated */\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\r\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\r\n * @ko {@link FlickingError}  .      .\r\n * @name ERROR_CODE\r\n * @constant\r\n * @type object\r\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>   </ko>\r\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko> CSS selector       </ko>\r\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko> , `null` `undefined`  </ko>\r\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking      ({@link Flicking#init}   )</ko>\r\n * @property {number} WRONG_OPTION One of the options is wrong<ko>     </ko>\r\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>    </ko>\r\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition} `position`      </ko>\r\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform`     (<=IE8)</ko>\r\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>   `stop()`  </ko>\r\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>    </ko>\r\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>    </ko>\r\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\r\n * <ko>(React, Angular, Vue ...)     </ko>\r\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}  ,    </ko>\r\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko> Flicking    .        </ko>\r\n * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual        </ko>\r\n */\nvar CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13,\n  NOT_ALLOWED_IN_VIRTUAL: 14\n};\nvar MESSAGE = {\n  WRONG_TYPE: function (wrongVal, correctTypes) {\n    return wrongVal + \"(\" + typeof wrongVal + \") is not a \" + correctTypes.map(function (type) {\n      return \"\\\"\" + type + \"\\\"\";\n    }).join(\" or \") + \".\";\n  },\n  ELEMENT_NOT_FOUND: function (selector) {\n    return \"Element with selector \\\"\" + selector + \"\\\" not found.\";\n  },\n  VAL_MUST_NOT_NULL: function (val, name) {\n    return name + \" should be provided. Given: \" + val;\n  },\n  NOT_ATTACHED_TO_FLICKING: \"This module is not attached to the Flicking instance. \\\"init()\\\" should be called first.\",\n  WRONG_OPTION: function (optionName, val) {\n    return \"Option \\\"\" + optionName + \"\\\" is not in correct format, given: \" + val;\n  },\n  INDEX_OUT_OF_RANGE: function (val, min, max) {\n    return \"Index \\\"\" + val + \"\\\" is out of range: should be between \" + min + \" and \" + max + \".\";\n  },\n  POSITION_NOT_REACHABLE: function (position) {\n    return \"Position \\\"\" + position + \"\\\" is not reachable.\";\n  },\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\",\n  NOT_ALLOWED_IN_VIRTUAL: \"This behavior is not allowed when the virtual option is enabled\"\n};\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n/**\r\n * Event type object with event name strings of {@link Flicking}\r\n * @ko {@link Flicking}     \r\n * @type {object}\r\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart </ko>\r\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd </ko>\r\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart </ko>\r\n * @property {\"move\"} MOVE move event<ko>move </ko>\r\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd </ko>\r\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange </ko>\r\n * @property {\"changed\"} CHANGED changed event<ko>changed </ko>\r\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore </ko>\r\n * @property {\"restored\"} RESTORED restored event<ko>restored </ko>\r\n * @property {\"select\"} SELECT select event<ko>select </ko>\r\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel </ko>\r\n * @property {\"panelChange\"} PANEL_CHANGE panelChange event<ko>panelChange </ko>\r\n * @example\r\n * ```ts\r\n * import { EVENTS } from \"@egjs/flicking\";\r\n * EVENTS.MOVE_START; // \"moveStart\"\r\n * ```\r\n */\n\nvar EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\",\n  PANEL_CHANGE: \"panelChange\"\n};\n/**\r\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\r\n * @ko {@link Flicking#align align}         \r\n * @type {object}\r\n * @property {\"prev\"} PREV left/top align<ko>/ </ko>\r\n * @property {\"center\"} CENTER center align<ko> </ko>\r\n * @property {\"next\"} NEXT right/bottom align<ko>/ </ko>\r\n */\n\nvar ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n};\n/**\r\n * An object of directions\r\n * @ko      \r\n * @type {object}\r\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\r\n * <ko>{@link Flicking#horizontal horizontal} `true`  , {@link Flicking#horizontal horizontal} `false`   </ko>\r\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\r\n * <ko>{@link Flicking#horizontal horizontal} `true`  , {@link Flicking#horizontal horizontal} `false`   </ko>\r\n * @property {null} NONE This value usually means it's the same position<ko>   </ko>\r\n */\n\nvar DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n};\n/**\r\n * An object with all possible {@link Flicking#moveType moveType}s\r\n * @ko Flicking  {@link Flicking#moveType moveType}   \r\n * @type {object}\r\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\r\n * <ko>Flicking {@link Flicking#control control} {@link SnapControl}   {@link Flicking#moveType moveType}</ko>\r\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\r\n * <ko>Flicking {@link Flicking#control control} {@link FreeControl}   {@link Flicking#moveType moveType}</ko>\r\n * @property {\"strict\"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}\r\n * <ko>Flicking {@link Flicking#control control} {@link StrictControl}   {@link Flicking#moveType moveType}</ko>\r\n */\n\nvar MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n  STRICT: \"strict\"\n};\nvar CLASS = {\n  VERTICAL: \"vertical\",\n  HIDDEN: \"flicking-hidden\",\n  DEFAULT_VIRTUAL: \"flicking-panel\"\n};\n/**\r\n * An object with all possible {@link Flicking#circularFallback circularFallback}s\r\n * @ko Flicking {@link Flicking#circularFallback circularFallback}      \r\n * @type {object}\r\n * @property {string} LINEAR \"linear\"\r\n * @property {string} BOUND \"bound\"\r\n */\n\nvar CIRCULAR_FALLBACK = {\n  LINEAR: \"linear\",\n  BOUND: \"bound\"\n};\n\nvar merge = function (target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    Object.keys(source).forEach(function (key) {\n      target[key] = source[key];\n    });\n  });\n  return target;\n};\nvar getElement = function (el, parent) {\n  var targetEl = null;\n\n  if (isString(el)) {\n    var parentEl = parent ? parent : document;\n    var queryResult = parentEl.querySelector(el);\n\n    if (!queryResult) {\n      throw new FlickingError(MESSAGE.ELEMENT_NOT_FOUND(el), CODE.ELEMENT_NOT_FOUND);\n    }\n\n    targetEl = queryResult;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\nvar checkExistence = function (value, nameOnErrMsg) {\n  if (value == null) {\n    throw new FlickingError(MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), CODE.VAL_MUST_NOT_NULL);\n  }\n};\nvar clamp = function (x, min, max) {\n  return Math.max(Math.min(x, max), min);\n};\nvar getFlickingAttached = function (val) {\n  if (!val) {\n    throw new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\nvar toArray = function (iterable) {\n  return [].slice.call(iterable);\n};\nvar parseAlign$1 = function (align, size) {\n  var alignPoint;\n\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n\n      default:\n        alignPoint = parseArithmeticSize(align, size);\n\n        if (alignPoint == null) {\n          throw new FlickingError(MESSAGE.WRONG_OPTION(\"align\", align), CODE.WRONG_OPTION);\n        }\n\n    }\n  } else {\n    alignPoint = align;\n  }\n\n  return alignPoint;\n};\nvar parseBounce = function (bounce, size) {\n  var parsedBounce;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = bounce.map(function (val) {\n      return parseArithmeticSize(val, size);\n    });\n  } else {\n    var parsedVal = parseArithmeticSize(bounce, size);\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(function (val) {\n    if (val == null) {\n      throw new FlickingError(MESSAGE.WRONG_OPTION(\"bounce\", bounce), CODE.WRONG_OPTION);\n    }\n\n    return val;\n  });\n};\nvar parseArithmeticSize = function (cssValue, base) {\n  var parsed = parseArithmeticExpression(cssValue);\n  if (parsed == null) return null;\n  return parsed.percentage * base + parsed.absolute;\n};\nvar parseArithmeticExpression = function (cssValue) {\n  var cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return {\n      percentage: 0,\n      absolute: cssValue\n    };\n  }\n\n  var parsed = {\n    percentage: 0,\n    absolute: 0\n  };\n  var idx = 0;\n  var matchResult = cssRegex.exec(cssValue);\n\n  while (matchResult != null) {\n    var sign = matchResult[1];\n    var value = matchResult[2];\n    var unit = matchResult[3];\n    var parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    } // Return default value for values not in good form\n\n\n    if (!sign) {\n      return null;\n    }\n\n    var signMultiplier = sign === \"+\" ? 1 : -1;\n\n    if (unit === \"%\") {\n      parsed.percentage += signMultiplier * (parsedValue / 100);\n    } else {\n      parsed.absolute += signMultiplier * parsedValue;\n    } // Match next occurrence\n\n\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  } // None-matched\n\n\n  if (idx === 0) {\n    return null;\n  }\n\n  return parsed;\n};\nvar parseCSSSizeValue = function (val) {\n  return isString(val) ? val : val + \"px\";\n};\nvar parsePanelAlign = function (align) {\n  return typeof align === \"object\" ? align.panel : align;\n};\nvar getDirection = function (start, end) {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\nvar parseElement = function (element) {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  var elements = [];\n  element.forEach(function (el) {\n    if (isString(el)) {\n      var tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n      elements.push.apply(elements, __spread(toArray(tempDiv.children)));\n\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), CODE.WRONG_TYPE);\n    }\n  });\n  return elements;\n};\nvar getMinusCompensatedIndex = function (idx, max) {\n  return idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n};\nvar includes = function (array, target) {\n  var e_1, _a;\n\n  try {\n    for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n      var val = array_1_1.value;\n      if (val === target) return true;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return false;\n};\nvar isString = function (val) {\n  return typeof val === \"string\";\n};\nvar circulatePosition = function (pos, min, max) {\n  var size = max - min;\n\n  if (pos < min) {\n    var offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    var offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\nvar find = function (array, checker) {\n  var e_2, _a;\n\n  try {\n    for (var array_2 = __values(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {\n      var val = array_2_1.value;\n\n      if (checker(val)) {\n        return val;\n      }\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return null;\n};\nvar findRight = function (array, checker) {\n  for (var idx = array.length - 1; idx >= 0; idx--) {\n    var val = array[idx];\n\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\nvar findIndex = function (array, checker) {\n  for (var idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\nvar getProgress = function (pos, prev, next) {\n  return (pos - prev) / (next - prev);\n}; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\nvar getStyle = function (el) {\n  return window.getComputedStyle(el) || el.currentStyle;\n};\nvar setSize = function (el, _a) {\n  var width = _a.width,\n      height = _a.height;\n\n  if (width != null) {\n    if (isString(width)) {\n      el.style.width = width;\n    } else {\n      el.style.width = width + \"px\";\n    }\n  }\n\n  if (height != null) {\n    if (isString(height)) {\n      el.style.height = height;\n    } else {\n      el.style.height = height + \"px\";\n    }\n  }\n};\nvar isBetween = function (val, min, max) {\n  return val >= min && val <= max;\n};\nvar circulateIndex = function (index, max) {\n  if (index >= max) {\n    return index % max;\n  } else if (index < 0) {\n    return getMinusCompensatedIndex((index + 1) % max - 1, max);\n  } else {\n    return index;\n  }\n};\nvar range = function (end) {\n  var arr = new Array(end);\n\n  for (var i = 0; i < end; i++) {\n    arr[i] = i;\n  }\n\n  return arr;\n};\nvar setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n};\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n/**\r\n * Special type of known error that {@link Flicking} throws.\r\n * @ko Flicking     throw \r\n * @property {number} code Error code<ko> </ko>\r\n * @property {string} message Error message<ko> </ko>\r\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\r\n * @example\r\n * ```ts\r\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\r\n * try {\r\n *   const flicking = new Flicking(\".flicking-viewport\")\r\n * } catch (e) {\r\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\r\n *     console.error(\"Element not found\")\r\n *   }\r\n * }\r\n * ```\r\n */\n\nvar FlickingError =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(FlickingError, _super);\n  /**\r\n   * @param message Error message<ko> </ko>\r\n   * @param code Error code<ko> </ko>\r\n   */\n\n\n  function FlickingError(message, code) {\n    var _this = _super.call(this, message) || this;\n\n    setPrototypeOf(_this, FlickingError.prototype);\n    _this.name = \"FlickingError\";\n    _this.code = code;\n    return _this;\n  }\n\n  return FlickingError;\n}(Error);\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n/**\r\n * A component that manages viewport size\r\n * @ko     \r\n */\n\nvar Viewport =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param el A viewport element<ko> </ko>\r\n   */\n  function Viewport(el) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  var __proto = Viewport.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    /**\r\n     * A viewport(root) element\r\n     * @ko (root) \r\n     * @type {HTMLElement}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._el;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"width\", {\n    /**\r\n     * Viewport width, without paddings\r\n     * @ko  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._width - this._padding.left - this._padding.right;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"height\", {\n    /**\r\n     * Viewport height, without paddings\r\n     * @ko  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._height - this._padding.top - this._padding.bottom;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"padding\", {\n    /**\r\n     * Viewport paddings\r\n     * @ko  CSS padding \r\n     * @type {object}\r\n     * @property {number} left CSS `padding-left`\r\n     * @property {number} right CSS `padding-right`\r\n     * @property {number} top CSS `padding-top`\r\n     * @property {number} bottom CSS `padding-bottom`\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._padding;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Change viewport's size.\r\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\r\n   * @ko   .\r\n   * `.flicking-viewport`    CSS width/height \r\n   * @param {object} [size] New viewport size<ko>  </ko>\r\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS   (px)</ko>\r\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS   (px)</ko>\r\n   */\n\n  __proto.setSize = function (_a) {\n    var width = _a.width,\n        height = _a.height;\n    var el = this._el;\n    var padding = this._padding;\n    var isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        var newWidth = isBorderBoxSizing ? width + padding.left + padding.right : width;\n        el.style.width = newWidth + \"px\";\n      }\n    }\n\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        var newHeight = isBorderBoxSizing ? height + padding.top + padding.bottom : height;\n        el.style.height = newHeight + \"px\";\n      }\n    }\n\n    this.resize();\n  };\n  /**\r\n   * Update width/height to the current viewport element's size\r\n   * @ko     / \r\n   */\n\n\n  __proto.resize = function () {\n    var el = this._el;\n    var elStyle = getStyle(el);\n    this._width = el.clientWidth;\n    this._height = el.clientHeight;\n    this._padding = {\n      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,\n      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,\n      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,\n      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  };\n\n  return Viewport;\n}();\n\nvar AutoResizer =\n/*#__PURE__*/\nfunction () {\n  function AutoResizer(flicking) {\n    var _this = this;\n\n    this._onResize = function () {\n      void _this._flicking.resize();\n    }; // eslint-disable-next-line @typescript-eslint/member-ordering\n\n\n    this._skipFirstResize = function () {\n      var isFirstResize = true;\n      return function () {\n        if (isFirstResize) {\n          isFirstResize = false;\n          return;\n        }\n\n        _this._onResize();\n      };\n    }();\n\n    this._flicking = flicking;\n    this._enabled = false;\n    this._resizeObserver = null;\n  }\n\n  var __proto = AutoResizer.prototype;\n  Object.defineProperty(__proto, \"enabled\", {\n    get: function () {\n      return this._enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.enable = function () {\n    var flicking = this._flicking;\n    var viewport = flicking.viewport;\n\n    if (this._enabled) {\n      this.disable();\n    }\n\n    if (flicking.useResizeObserver && !!window.ResizeObserver) {\n      var viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;\n      var resizeObserver = viewportSizeNot0 ? new ResizeObserver(this._skipFirstResize) : new ResizeObserver(this._onResize);\n      resizeObserver.observe(flicking.viewport.element);\n      this._resizeObserver = resizeObserver;\n    } else {\n      window.addEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = true;\n    return this;\n  };\n\n  __proto.disable = function () {\n    if (!this._enabled) return this;\n    var resizeObserver = this._resizeObserver;\n\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      this._resizeObserver = null;\n    } else {\n      window.removeEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = false;\n    return this;\n  };\n\n  return AutoResizer;\n}();\n\n/**\r\n * @internal\r\n */\nvar VanillaElementProvider =\n/*#__PURE__*/\nfunction () {\n  function VanillaElementProvider(element) {\n    this._element = element;\n    this._rendered = true;\n  }\n\n  var __proto = VanillaElementProvider.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    get: function () {\n      return this._element;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"rendered\", {\n    get: function () {\n      return this._rendered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.show = function (flicking) {\n    var el = this.element;\n    var cameraEl = flicking.camera.element;\n\n    if (el.parentElement !== cameraEl) {\n      cameraEl.appendChild(el);\n      this._rendered = true;\n    }\n  };\n\n  __proto.hide = function (flicking) {\n    var el = this.element;\n    var cameraEl = flicking.camera.element;\n\n    if (el.parentElement === cameraEl) {\n      cameraEl.removeChild(el);\n      this._rendered = false;\n    }\n  };\n\n  return VanillaElementProvider;\n}();\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n/**\r\n * @internal\r\n */\nvar VirtualElementProvider =\n/*#__PURE__*/\nfunction () {\n  function VirtualElementProvider(flicking) {\n    this._flicking = flicking;\n  }\n\n  var __proto = VirtualElementProvider.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    get: function () {\n      return this._virtualElement.nativeElement;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"rendered\", {\n    get: function () {\n      return this._virtualElement.visible;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"_virtualElement\", {\n    get: function () {\n      var flicking = this._flicking;\n      var elIndex = this._panel.elementIndex;\n      var virtualElements = flicking.virtual.elements;\n      return virtualElements[elIndex];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function (panel) {\n    this._panel = panel;\n  };\n\n  __proto.show = function () {// DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  };\n\n  __proto.hide = function () {// DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  };\n\n  return VirtualElementProvider;\n}();\n\n/**\r\n * A manager class to add / remove virtual panels\r\n */\n\nvar VirtualManager =\n/*#__PURE__*/\nfunction () {\n  function VirtualManager(flicking, options) {\n    var _a, _b, _c, _d;\n\n    this._flicking = flicking;\n    this._renderPanel = (_a = options === null || options === void 0 ? void 0 : options.renderPanel) !== null && _a !== void 0 ? _a : function () {\n      return \"\";\n    };\n    this._initialPanelCount = (_b = options === null || options === void 0 ? void 0 : options.initialPanelCount) !== null && _b !== void 0 ? _b : -1;\n    this._cache = (_c = options === null || options === void 0 ? void 0 : options.cache) !== null && _c !== void 0 ? _c : false;\n    this._panelClass = (_d = options === null || options === void 0 ? void 0 : options.panelClass) !== null && _d !== void 0 ? _d : CLASS.DEFAULT_VIRTUAL;\n    this._elements = [];\n  }\n\n  var __proto = VirtualManager.prototype;\n  Object.defineProperty(__proto, \"elements\", {\n    get: function () {\n      return this._elements;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"renderPanel\", {\n    // Options\n\n    /**\r\n     * A rendering function for the panel element's innerHTML\r\n     * @ko   innerHTML  \r\n     * @type {function}\r\n     * @param {VirtualPanel} panel Instance of the panel<ko> </ko>\r\n     * @param {number} index Index of the panel<ko> </ko>\r\n     * @default \"() => {}\"\r\n     */\n    get: function () {\n      return this._renderPanel;\n    },\n    set: function (val) {\n      this._renderPanel = val;\n\n      this._flicking.renderer.panels.forEach(function (panel) {\n        return panel.uncacheRenderResult();\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"initialPanelCount\", {\n    /**\r\n     * Initial panel count to render\r\n     * @ko    \r\n     * @readonly\r\n     * @type {number}\r\n     * @default -1\r\n     */\n    get: function () {\n      return this._initialPanelCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"cache\", {\n    /**\r\n     * Whether to cache rendered panel's innerHTML\r\n     * @ko   innerHTML   \r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._cache;\n    },\n    set: function (val) {\n      this._cache = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panelClass\", {\n    /**\r\n     * The class name that will be applied to rendered panel elements\r\n     * @ko      \r\n     * @type {string}\r\n     * @default \"flicking-panel\"\r\n     */\n    get: function () {\n      return this._panelClass;\n    },\n    set: function (val) {\n      this._panelClass = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.init = function () {\n    var flicking = this._flicking;\n    if (!flicking.virtualEnabled) return;\n\n    if (!flicking.externalRenderer && !flicking.renderExternal) {\n      this._initVirtualElements();\n    }\n\n    var virtualElements = flicking.camera.children;\n    this._elements = virtualElements.map(function (el) {\n      return {\n        nativeElement: el,\n        visible: true\n      };\n    });\n  };\n\n  __proto.show = function (index) {\n    var el = this._elements[index];\n    var nativeEl = el.nativeElement;\n    el.visible = true;\n\n    if (nativeEl.style.display) {\n      nativeEl.style.display = \"\";\n    }\n  };\n\n  __proto.hide = function (index) {\n    var el = this._elements[index];\n    var nativeEl = el.nativeElement;\n    el.visible = false;\n    nativeEl.style.display = \"none\";\n  };\n  /**\r\n   * Add new virtual panels at the end of the list\r\n   * @ko      \r\n   * @param {number} count The number of panels to add<ko>  </ko>\r\n   * @returns {Array<VirtualPanel>} The new panels added<ko>  </ko>\r\n   */\n\n\n  __proto.append = function (count) {\n    if (count === void 0) {\n      count = 1;\n    }\n\n    var flicking = this._flicking;\n    return this.insert(flicking.panels.length, count);\n  };\n  /**\r\n   * Add new virtual panels at the start of the list\r\n   * @ko      \r\n   * @param {number} count The number of panels to add<ko>  </ko>\r\n   * @returns {Array<VirtualPanel>} The new panels added<ko>  </ko>\r\n   */\n\n\n  __proto.prepend = function (count) {\n    if (count === void 0) {\n      count = 1;\n    }\n\n    return this.insert(0, count);\n  };\n  /**\r\n   * Add new virtual panels at the given index\r\n   * @ko      \r\n   * @param {number} count The number of panels to add<ko>  </ko>\r\n   * @returns {Array<VirtualPanel>} The new panels added<ko>  </ko>\r\n   */\n\n\n  __proto.insert = function (index, count) {\n    if (count === void 0) {\n      count = 1;\n    }\n\n    if (count <= 0) return [];\n    var flicking = this._flicking;\n    return flicking.renderer.batchInsert({\n      index: index,\n      elements: range(count),\n      hasDOMInElements: false\n    });\n  };\n  /**\r\n   * Remove panels at the given index\r\n   * @ko    \r\n   * @param {number} count The number of panels to remove<ko>  </ko>\r\n   * @returns {Array<VirtualPanel>} The panels removed<ko> </ko>\r\n   */\n\n\n  __proto.remove = function (index, count) {\n    if (count <= 0) return [];\n    var flicking = this._flicking;\n    return flicking.renderer.batchRemove({\n      index: index,\n      deleteCount: count,\n      hasDOMInElements: false\n    });\n  };\n\n  __proto._initVirtualElements = function () {\n    var _this = this;\n\n    var flicking = this._flicking;\n    var cameraElement = flicking.camera.element;\n    var panelsPerView = flicking.panelsPerView;\n    var fragment = document.createDocumentFragment();\n    var newElements = range(panelsPerView + 1).map(function (idx) {\n      var panelEl = document.createElement(\"div\");\n      panelEl.className = _this._panelClass;\n      panelEl.dataset.elementIndex = idx.toString();\n      return panelEl;\n    });\n    newElements.forEach(function (el) {\n      fragment.appendChild(el);\n    });\n    cameraElement.appendChild(fragment);\n  };\n\n  return VirtualManager;\n}();\n\n/**\r\n * All possible @egjs/axes event keys\r\n * @internal\r\n */\nvar EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n};\n/**\r\n * An Axis key that Flicking uses\r\n * @internal\r\n */\n\nvar POSITION_KEY = \"flick\";\n\nvar STATE_TYPE;\n\n(function (STATE_TYPE) {\n  STATE_TYPE[STATE_TYPE[\"IDLE\"] = 0] = \"IDLE\";\n  STATE_TYPE[STATE_TYPE[\"HOLDING\"] = 1] = \"HOLDING\";\n  STATE_TYPE[STATE_TYPE[\"DRAGGING\"] = 2] = \"DRAGGING\";\n  STATE_TYPE[STATE_TYPE[\"ANIMATING\"] = 3] = \"ANIMATING\";\n  STATE_TYPE[STATE_TYPE[\"DISABLED\"] = 4] = \"DISABLED\";\n})(STATE_TYPE || (STATE_TYPE = {}));\n/**\r\n * A component that shows the current status of the user input or the animation\r\n * @ko        \r\n * @internal\r\n */\n\n\nvar State =\n/*#__PURE__*/\nfunction () {\n  function State() {\n    this._delta = 0;\n    this._targetPanel = null;\n  }\n\n  var __proto = State.prototype;\n  Object.defineProperty(__proto, \"delta\", {\n    /**\r\n     * A sum of delta values of change events from the last hold event of Axes\r\n     * @ko  hold change    delta \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._delta;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"targetPanel\", {\n    /**\r\n     * A panel to set as {@link Control#activePanel} after the animation is finished\r\n     * @ko   {@link Control#activePanel}  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._targetPanel;\n    },\n    set: function (val) {\n      this._targetPanel = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * An callback which is called when state has changed to this state\r\n   * @ko      \r\n   * @param {State} prevState An previous state<ko> </ko>\r\n   * @return {void}\r\n   */\n\n  __proto.onEnter = function (prevState) {\n    this._delta = prevState._delta;\n    this._targetPanel = prevState._targetPanel;\n  };\n  /**\r\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold}  \r\n   * @param {object} [ctx] Event context<ko> </ko>\r\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking </ko>\r\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\r\n   * <ko>Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} </ko>\r\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.onHold = function (ctx) {// DO NOTHING\n  };\n  /**\r\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change}  \r\n   * @param {object} [ctx] Event context<ko> </ko>\r\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking </ko>\r\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\r\n   * <ko>Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} </ko>\r\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.onChange = function (ctx) {// DO NOTHING\n  };\n  /**\r\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release}  \r\n   * @param {object} [ctx] Event context<ko> </ko>\r\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking </ko>\r\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\r\n   * <ko>Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} </ko>\r\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.onRelease = function (ctx) {// DO NOTHING\n  };\n  /**\r\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd}  \r\n   * @param {object} [ctx] Event context<ko> </ko>\r\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking </ko>\r\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\r\n   * <ko>Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} </ko>\r\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.onAnimationEnd = function (ctx) {// DO NOTHING\n  };\n  /**\r\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish}  \r\n   * @param {object} [ctx] Event context<ko> </ko>\r\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking </ko>\r\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} </ko>\r\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.onFinish = function (ctx) {// DO NOTHING\n  };\n\n  __proto._moveToChangedPosition = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    var delta = axesEvent.delta[POSITION_KEY];\n\n    if (!delta) {\n      return;\n    }\n\n    this._delta += delta;\n    var camera = flicking.camera;\n    var prevPosition = camera.position;\n    var position = axesEvent.pos[POSITION_KEY];\n    var newPosition = flicking.circularEnabled ? circulatePosition(position, camera.range.min, camera.range.max) : position;\n    camera.lookAt(newPosition);\n    var moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[POSITION_KEY]),\n      axesEvent: axesEvent\n    });\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  };\n\n  return State;\n}();\n\n/**\r\n * A default state when there's no user input and no animation's playing\r\n * @ko   ,     \r\n * @internal\r\n */\n\nvar IdleState =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IdleState, _super);\n\n  function IdleState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {false}\r\n     * @readonly\r\n     */\n\n\n    _this.holding = false;\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {false}\r\n     * @readonly\r\n     */\n\n    _this.animating = false;\n    return _this;\n  }\n\n  var __proto = IdleState.prototype;\n\n  __proto.onEnter = function () {\n    this._delta = 0;\n    this._targetPanel = null;\n  };\n\n  __proto.onHold = function (ctx) {\n    // Shouldn't do any action until any panels on flicking area\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    var holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent: axesEvent\n    });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }; // By methods call\n\n\n  __proto.onChange = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    var controller = flicking.control.controller;\n    var animatingContext = controller.animatingContext;\n    var moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent: axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  };\n\n  return IdleState;\n}(State);\n\n/**\r\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\r\n * @ko   ,    \r\n * @internal\r\n */\n\nvar HoldingState =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(HoldingState, _super);\n\n  function HoldingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {true}\r\n     * @readonly\r\n     */\n\n\n    _this.holding = true;\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {false}\r\n     * @readonly\r\n     */\n\n    _this.animating = false;\n    _this._releaseEvent = null;\n    return _this;\n  }\n\n  var __proto = HoldingState.prototype;\n\n  __proto.onChange = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    var inputEvent = axesEvent.inputEvent;\n    var offset = flicking.horizontal ? inputEvent.offsetX : inputEvent.offsetY;\n    var moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent: axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  };\n\n  __proto.onRelease = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent: axesEvent\n    }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({\n        flick: flicking.camera.position\n      }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    } // Can't handle select event here,\n    // As \"finish\" axes event happens\n\n\n    this._releaseEvent = axesEvent;\n  };\n\n  __proto.onFinish = function (ctx) {\n    var e_1, _a;\n\n    var flicking = ctx.flicking,\n        transitTo = ctx.transitTo; // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    } // Handle release event here\n    // To prevent finish event called twice\n\n\n    var releaseEvent = this._releaseEvent; // Static click\n\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n\n    var srcEvent = releaseEvent.inputEvent.srcEvent;\n    var clickedElement;\n\n    if (srcEvent.type === \"touchend\") {\n      var touchEvent = srcEvent;\n      var touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n\n    var panels = flicking.renderer.panels;\n    var clickedPanel = null;\n\n    try {\n      for (var panels_1 = __values(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {\n        var panel = panels_1_1.value;\n\n        if (panel.contains(clickedElement)) {\n          clickedPanel = panel;\n          break;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (clickedPanel) {\n      var cameraPosition = flicking.camera.position;\n      var clickedPanelPosition = clickedPanel.position;\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  };\n\n  return HoldingState;\n}(State);\n\n/**\r\n * A state that activates when user's dragging the Flicking area\r\n * @ko   \r\n * @internal\r\n */\n\nvar DraggingState =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DraggingState, _super);\n\n  function DraggingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {true}\r\n     * @readonly\r\n     */\n\n\n    _this.holding = true;\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {true}\r\n     * @readonly\r\n     */\n\n    _this.animating = true;\n    return _this;\n  }\n\n  var __proto = DraggingState.prototype;\n\n  __proto.onChange = function (ctx) {\n    this._moveToChangedPosition(ctx);\n  };\n\n  __proto.onRelease = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo; // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent: axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n    var control = flicking.control;\n    var position = axesEvent.destPos[POSITION_KEY];\n    var duration = Math.max(axesEvent.duration, flicking.duration);\n    void control.moveToPosition(position, duration, axesEvent);\n  };\n\n  return DraggingState;\n}(State);\n\n/**\r\n * A state that activates when Flicking's animating by user input or method call\r\n * @ko      Flicking   \r\n * @internal\r\n */\n\nvar AnimatingState =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(AnimatingState, _super);\n\n  function AnimatingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {false}\r\n     * @readonly\r\n     */\n\n\n    _this.holding = false;\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {true}\r\n     * @readonly\r\n     */\n\n    _this.animating = true;\n    return _this;\n  }\n\n  var __proto = AnimatingState.prototype;\n\n  __proto.onHold = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    this._delta = 0;\n    flicking.control.updateInput();\n    var holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent: axesEvent\n    });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  };\n\n  __proto.onChange = function (ctx) {\n    this._moveToChangedPosition(ctx);\n  };\n\n  __proto.onFinish = function (ctx) {\n    var flicking = ctx.flicking,\n        axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo;\n    var control = flicking.control;\n    var controller = control.controller;\n    var animatingContext = controller.animatingContext;\n    transitTo(STATE_TYPE.IDLE);\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent: axesEvent\n    }));\n    control.setActive(this._targetPanel, control.activePanel, axesEvent.isTrusted);\n  };\n\n  return AnimatingState;\n}(State);\n\n/**\r\n * A state that activates when Flicking is stopped by event's `stop` method\r\n * @ko  `stop`  Flicking  \r\n * @internal\r\n */\n\nvar DisabledState =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DisabledState, _super);\n\n  function DisabledState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {false}\r\n     * @readonly\r\n     */\n\n\n    _this.holding = false;\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {true}\r\n     * @readonly\r\n     */\n\n    _this.animating = true;\n    return _this;\n  }\n\n  var __proto = DisabledState.prototype;\n\n  __proto.onAnimationEnd = function (ctx) {\n    var transitTo = ctx.transitTo;\n    transitTo(STATE_TYPE.IDLE);\n  };\n\n  __proto.onChange = function (ctx) {\n    var axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo; // Can stop Axes's change event\n\n    axesEvent.stop();\n    transitTo(STATE_TYPE.IDLE);\n  };\n\n  __proto.onRelease = function (ctx) {\n    var axesEvent = ctx.axesEvent,\n        transitTo = ctx.transitTo; // This is needed when stopped hold start event\n\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  };\n\n  return DisabledState;\n}(State);\n\n/**\r\n * @internal\r\n */\n\nvar StateMachine =\n/*#__PURE__*/\nfunction () {\n  function StateMachine() {\n    var _this = this;\n\n    this.transitTo = function (nextStateType) {\n      var nextState;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      nextState.onEnter(_this._state);\n      _this._state = nextState;\n      return _this._state;\n    };\n\n    this._state = new IdleState();\n  }\n\n  var __proto = StateMachine.prototype;\n  Object.defineProperty(__proto, \"state\", {\n    get: function () {\n      return this._state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.fire = function (eventType, externalCtx) {\n    var currentState = this._state;\n\n    var ctx = __assign(__assign({}, externalCtx), {\n      transitTo: this.transitTo\n    });\n\n    switch (eventType) {\n      case EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n\n      case EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n\n      case EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n\n      case EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n\n      case EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  };\n\n  return StateMachine;\n}();\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n/**\r\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\r\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}    \r\n * @internal\r\n */\n\nvar AxesController =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function AxesController() {\n    var _this = this;\n\n    this._onAxesHold = function () {\n      _this._dragged = false;\n    };\n\n    this._onAxesChange = function () {\n      _this._dragged = true;\n    };\n\n    this._preventClickWhenDragged = function (e) {\n      if (_this._dragged) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      _this._dragged = false;\n    };\n\n    this._resetInternalValues();\n\n    this._stateMachine = new StateMachine();\n  }\n\n  var __proto = AxesController.prototype;\n  Object.defineProperty(__proto, \"axes\", {\n    /**\r\n     * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\r\n     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} \r\n     * @type {Axes}\r\n     * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._axes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"stateMachine\", {\n    /**\r\n     * @internal\r\n     */\n    get: function () {\n      return this._stateMachine;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"state\", {\n    /**\r\n     * A activated {@link State} that shows the current status of the user input or the animation\r\n     * @ko   {@link State}       \r\n     * @type {State}\r\n     */\n    get: function () {\n      return this._stateMachine.state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"animatingContext\", {\n    /**\r\n     * A context of the current animation playing\r\n     * @ko    \r\n     * @type {object}\r\n     * @property {number} start A start position of the animation<ko>  </ko>\r\n     * @property {number} end A end position of the animation<ko>  </ko>\r\n     * @property {number} offset camera offset<ko> </ko>\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._animatingContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"controlParams\", {\n    /**\r\n     * A current control parameters of the Axes instance\r\n     * @ko   Axes \r\n     * @type {ControlParams}\r\n     */\n    get: function () {\n      var axes = this._axes;\n\n      if (!axes) {\n        return {\n          range: {\n            min: 0,\n            max: 0\n          },\n          position: 0,\n          circular: false\n        };\n      }\n\n      var axis = axes.axis[POSITION_KEY];\n      return {\n        range: {\n          min: axis.range[0],\n          max: axis.range[1]\n        },\n        circular: axis.circular[0],\n        position: this.position\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"enabled\", {\n    /**\r\n     * A Boolean indicating whether the user input is enabled\r\n     * @ko      \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      var _a, _b;\n\n      return (_b = (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.isEnable()) !== null && _b !== void 0 ? _b : false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"position\", {\n    /**\r\n     * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\r\n     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}     \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var _a, _b;\n\n      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.get([POSITION_KEY])[POSITION_KEY]) !== null && _b !== void 0 ? _b : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"range\", {\n    /**\r\n     * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\r\n     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}      \r\n     * @type {number[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      var _a, _b;\n\n      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].range) !== null && _b !== void 0 ? _b : [0, 0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"bounce\", {\n    /**\r\n     * Actual bounce size(px)\r\n     * @ko  bounce (px )\r\n     * @type {number[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      var _a;\n\n      return (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].bounce;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize AxesController\r\n   * @ko AxesController \r\n   * @param {Flicking} flicking An instance of Flicking\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n  __proto.init = function (flicking) {\n    var _a;\n\n    var _this = this;\n\n    this._flicking = flicking;\n    this._axes = new Axes((_a = {}, _a[POSITION_KEY] = {\n      range: [0, 0],\n      circular: false,\n      bounce: [0, 0]\n    }, _a), {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true\n    });\n    var axes = this._axes;\n    axes.connect(flicking.horizontal ? [POSITION_KEY, \"\"] : [\"\", POSITION_KEY], this._panInput);\n\n    var _loop_1 = function (key) {\n      var eventType = EVENT[key];\n      axes.on(eventType, function (e) {\n        _this._stateMachine.fire(eventType, {\n          flicking: flicking,\n          axesEvent: e\n        });\n      });\n    };\n\n    for (var key in EVENT) {\n      _loop_1(key);\n    }\n\n    return this;\n  };\n  /**\r\n   * Destroy AxesController and return to initial state\r\n   * @ko AxesController   \r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    var _a;\n\n    if (this._axes) {\n      this.removePreventClickHandler();\n\n      this._axes.destroy();\n    }\n\n    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.destroy();\n\n    this._resetInternalValues();\n  };\n  /**\r\n   * Enable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.enable = function () {\n    var _a;\n\n    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.enable();\n    return this;\n  };\n  /**\r\n   * Disable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.disable = function () {\n    var _a;\n\n    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.disable();\n    return this;\n  };\n  /**\r\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\r\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}  \r\n   * @chainable\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\r\n   * <ko>{@link AxesController#init init}    </ko>\r\n   * @return {this}\r\n   */\n\n\n  __proto.update = function (controlParams) {\n    var _a;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var axes = this._axes;\n    var axis = axes.axis[POSITION_KEY];\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n    axes.axm.set((_a = {}, _a[POSITION_KEY] = controlParams.position, _a));\n    return this;\n  };\n  /**\r\n   * Attach a handler to the camera element to prevent click events during animation\r\n   * @ko         \r\n   * @return {this}\r\n   */\n\n\n  __proto.addPreventClickHandler = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var axes = this._axes;\n    var cameraEl = flicking.camera.element;\n    axes.on(EVENT.HOLD, this._onAxesHold);\n    axes.on(EVENT.CHANGE, this._onAxesChange);\n    cameraEl.addEventListener(\"click\", this._preventClickWhenDragged, true);\n    return this;\n  };\n  /**\r\n   * Detach a handler to the camera element to prevent click events during animation\r\n   * @ko         \r\n   * @return {this}\r\n   */\n\n\n  __proto.removePreventClickHandler = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var axes = this._axes;\n    var cameraEl = flicking.camera.element;\n    axes.off(EVENT.HOLD, this._onAxesHold);\n    axes.off(EVENT.CHANGE, this._onAxesChange);\n    cameraEl.removeEventListener(\"click\", this._preventClickWhenDragged, true);\n    return this;\n  };\n  /**\r\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\r\n   * @ko Axes {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo}     \r\n   * @param {number} position A position to move<ko> </ko>\r\n   * @param {number} duration Duration of the animation (unit: ms)<ko>   (: ms)</ko>\r\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>   ,   {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo}   .</ko>\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}    |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.animateTo = function (position, duration, axesEvent) {\n    var _a;\n\n    var _this = this;\n\n    var _b;\n\n    var axes = this._axes;\n    var state = this._stateMachine.state;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    var startPos = axes.get([POSITION_KEY])[POSITION_KEY];\n\n    if (startPos === position) {\n      var flicking = getFlickingAttached(this._flicking);\n      flicking.camera.lookAt(position);\n\n      if (state.targetPanel) {\n        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, (_b = axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) !== null && _b !== void 0 ? _b : false);\n      }\n\n      return Promise.resolve();\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    var animate = function () {\n      var _a, _b;\n\n      var resetContext = function () {\n        _this._animatingContext = {\n          start: 0,\n          end: 0,\n          offset: 0\n        };\n      };\n\n      axes.once(EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo((_a = {}, _a[POSITION_KEY] = position, _a), duration);\n      } else {\n        axes.setTo((_b = {}, _b[POSITION_KEY] = position, _b), duration);\n      }\n    };\n\n    if (duration === 0) {\n      var flicking = getFlickingAttached(this._flicking);\n      var camera = flicking.camera;\n      animate();\n      var newPos = flicking.circularEnabled ? circulatePosition(position, camera.range.min, camera.range.max) : position;\n      axes.axm.set((_a = {}, _a[POSITION_KEY] = newPos, _a));\n      return Promise.resolve();\n    } else {\n      return new Promise(function (resolve, reject) {\n        var animationFinishHandler = function () {\n          axes.off(EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        var interruptionHandler = function () {\n          axes.off(EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(MESSAGE.ANIMATION_INTERRUPTED, CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(EVENT.FINISH, animationFinishHandler);\n        axes.once(EVENT.HOLD, interruptionHandler);\n        animate();\n      });\n    }\n  };\n\n  __proto._resetInternalValues = function () {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = {\n      start: 0,\n      end: 0,\n      offset: 0\n    };\n    this._dragged = false;\n  };\n\n  return AxesController;\n}();\n\n/**\r\n * A component that manages inputs and animation of Flicking\r\n * @ko Flicking   &   \r\n */\n\nvar Control =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function Control() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  var __proto = Control.prototype;\n  Object.defineProperty(__proto, \"controller\", {\n    /**\r\n     * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\r\n     * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}    \r\n     * @type {AxesController}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._controller;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"activeIndex\", {\n    /**\r\n     * Index number of the {@link Flicking#currentPanel currentPanel}\r\n     * @ko {@link Flicking#currentPanel currentPanel}  \r\n     * @type {number}\r\n     * @default 0\r\n     * @readonly\r\n     */\n    get: function () {\n      var _a, _b;\n\n      return (_b = (_a = this._activePanel) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"activePanel\", {\n    /**\r\n     * An active panel\r\n     * @ko   \r\n     * @type {Panel | null}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._activePanel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"animating\", {\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._controller.state.animating;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"holding\", {\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._controller.state.holding;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize Control\r\n   * @ko Control \r\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking </ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n  __proto.init = function (flicking) {\n    this._flicking = flicking;\n\n    this._controller.init(flicking);\n\n    return this;\n  };\n  /**\r\n   * Destroy Control and return to initial state\r\n   * @ko Control   \r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  };\n  /**\r\n   * Enable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.enable = function () {\n    this._controller.enable();\n\n    return this;\n  };\n  /**\r\n   * Disable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.disable = function () {\n    this._controller.disable();\n\n    return this;\n  };\n  /**\r\n   * Update position after resizing\r\n   * @ko resize  position \r\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize       progress </ko>\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @chainable\r\n   * @return {Promise<void>}\r\n   */\n\n\n  __proto.updatePosition = function (_progressInPanel) {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var activePanel = this._activePanel;\n\n    if (activePanel) {\n      camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  };\n  /**\r\n   * Update {@link Control#controller controller}'s state\r\n   * @ko {@link Control#controller controller}   \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateInput = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n\n    this._controller.update(camera.controlParams);\n\n    return this;\n  };\n  /**\r\n   * Reset {@link Control#activePanel activePanel} to `null`\r\n   * @ko {@link Control#activePanel activePanel} `null` \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.resetActive = function () {\n    this._activePanel = null;\n    return this;\n  };\n  /**\r\n   * Move {@link Camera} to the given panel\r\n   * @ko {@link Camera}    \r\n   * @param {Panel} panel The target panel to move<ko> </ko>\r\n   * @param {object} options An options object<ko> </ko>\r\n   * @param {number} duration Duration of the animation (unit: ms)<ko>   (: ms)</ko>\r\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\r\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes} {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} </ko>\r\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko> . {@link Flicking#circular circular}    </ko>\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|  , Camera {@link Camera#range range}   |\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}    |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.moveToPanel = function (panel, _a) {\n    var duration = _a.duration,\n        _b = _a.direction,\n        direction = _b === void 0 ? DIRECTION.NONE : _b,\n        axesEvent = _a.axesEvent;\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, camera, position, nearestAnchor, camPos_1, camRangeDiff, possiblePositions;\n      return __generator(this, function (_c) {\n        flicking = getFlickingAttached(this._flicking);\n        camera = flicking.camera;\n        position = panel.position;\n        nearestAnchor = camera.findNearestAnchor(position);\n\n        if (panel.removed || !nearestAnchor) {\n          return [2\n          /*return*/\n          , Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(panel.position), CODE.POSITION_NOT_REACHABLE))];\n        }\n\n        if (!camera.canReach(panel)) {\n          // Override position & panel if that panel is not reachable\n          position = nearestAnchor.position;\n          panel = nearestAnchor.panel;\n        } else if (flicking.circularEnabled) {\n          camPos_1 = this._controller.position;\n          camRangeDiff = camera.rangeDiff;\n          possiblePositions = [position, position + camRangeDiff, position - camRangeDiff].filter(function (pos) {\n            if (direction === DIRECTION.NONE) return true;\n            return direction === DIRECTION.PREV ? pos <= camPos_1 : pos >= camPos_1;\n          });\n          position = possiblePositions.reduce(function (nearestPosition, pos) {\n            if (Math.abs(camPos_1 - pos) < Math.abs(camPos_1 - nearestPosition)) {\n              return pos;\n            } else {\n              return nearestPosition;\n            }\n          }, Infinity);\n        }\n\n        this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n        return [2\n        /*return*/\n        , this._animateToPosition({\n          position: position,\n          duration: duration,\n          newActivePanel: panel,\n          axesEvent: axesEvent\n        })];\n      });\n    });\n  };\n  /**\r\n   * @internal\r\n   */\n\n\n  __proto.setActive = function (newActivePanel, prevActivePanel, isTrusted) {\n    var _a;\n\n    var flicking = getFlickingAttached(this._flicking);\n    this._activePanel = newActivePanel;\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: (_a = prevActivePanel === null || prevActivePanel === void 0 ? void 0 : prevActivePanel.index) !== null && _a !== void 0 ? _a : -1,\n        prevPanel: prevActivePanel,\n        isTrusted: isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted: isTrusted\n      }));\n    }\n  };\n\n  __proto._triggerIndexChangeEvent = function (panel, position, axesEvent) {\n    var _a;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    var camera = flicking.camera;\n    var activePanel = this._activePanel;\n    var event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel: panel,\n      isTrusted: (axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) || false,\n      direction: getDirection((_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.position) !== null && _a !== void 0 ? _a : camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(MESSAGE.STOP_CALLED_BY_USER, CODE.STOP_CALLED_BY_USER);\n    }\n  };\n\n  __proto._animateToPosition = function (_a) {\n    var position = _a.position,\n        duration = _a.duration,\n        newActivePanel = _a.newActivePanel,\n        axesEvent = _a.axesEvent;\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, animate, state;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        flicking = getFlickingAttached(this._flicking);\n\n        animate = function () {\n          return _this._controller.animateTo(position, duration, axesEvent);\n        };\n\n        state = this._controller.state;\n        state.targetPanel = newActivePanel;\n\n        if (duration <= 0) {\n          return [2\n          /*return*/\n          , animate()];\n        } else {\n          return [2\n          /*return*/\n          , animate().then(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , flicking.renderer.render()];\n\n                  case 1:\n                    _a.sent();\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }).catch(function (err) {\n            if (axesEvent && err instanceof FlickingError && err.code === CODE.ANIMATION_INTERRUPTED) return;\n            throw err;\n          })];\n        }\n      });\n    });\n  };\n\n  return Control;\n}();\n\n/**\r\n * A data component that has actual position where the camera should be stopped at\r\n * @ko        \r\n */\nvar AnchorPoint =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param {object} options An options object<ko> </ko>\r\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint </ko>\r\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint </ko>\r\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint   {@link Panel}</ko>\r\n   */\n  function AnchorPoint(_a) {\n    var index = _a.index,\n        position = _a.position,\n        panel = _a.panel;\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n\n  var __proto = AnchorPoint.prototype;\n  Object.defineProperty(__proto, \"index\", {\n    /**\r\n     * Index of AnchorPoint\r\n     * @ko AnchorPoint \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._index;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"position\", {\n    /**\r\n     * Position of AnchorPoint\r\n     * @ko AnchorPoint \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._pos;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panel\", {\n    /**\r\n     * A {@link Panel} instance AnchorPoint is referencing to\r\n     * @ko AnchorPoint   {@link Panel}\r\n     * @type {Panel}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._panel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return AnchorPoint;\n}();\n\n/**\r\n * A {@link Control} that uses a release momentum to choose destination panel\r\n * @ko            {@link Control}\r\n */\n\nvar SnapControl =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SnapControl, _super);\n  /** */\n\n\n  function SnapControl(_a) {\n    var _b = (_a === void 0 ? {} : _a).count,\n        count = _b === void 0 ? Infinity : _b;\n\n    var _this = _super.call(this) || this;\n\n    _this._count = count;\n    return _this;\n  }\n\n  var __proto = SnapControl.prototype;\n  Object.defineProperty(__proto, \"count\", {\n    /**\r\n     * Maximum number of panels can go after release\r\n     * @ko          \r\n     * @type {number}\r\n     * @default Infinity\r\n     */\n    get: function () {\n      return this._count;\n    },\n    set: function (val) {\n      this._count = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Move {@link Camera} to the given position\r\n   * @ko {@link Camera}   \r\n   * @param {number} position The target position to move<ko> </ko>\r\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>     (: ms)</ko>\r\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\r\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes} {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} </ko>\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|  , Camera {@link Camera#range range}   |\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}    |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>   resolve Promise</ko>\r\n   */\n\n  __proto.moveToPosition = function (position, duration, axesEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, camera, activeAnchor, anchorAtCamera, state, snapThreshold, posDelta, absPosDelta, snapDelta, targetAnchor;\n      return __generator(this, function (_a) {\n        flicking = getFlickingAttached(this._flicking);\n        camera = flicking.camera;\n        activeAnchor = camera.findActiveAnchor();\n        anchorAtCamera = camera.findNearestAnchor(camera.position);\n        state = flicking.control.controller.state;\n\n        if (!activeAnchor || !anchorAtCamera) {\n          return [2\n          /*return*/\n          , Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE))];\n        }\n\n        snapThreshold = this._calcSnapThreshold(position, activeAnchor);\n        posDelta = flicking.animating ? state.delta : position - camera.position;\n        absPosDelta = Math.abs(posDelta);\n        snapDelta = axesEvent && axesEvent.delta[POSITION_KEY] !== 0 ? Math.abs(axesEvent.delta[POSITION_KEY]) : absPosDelta;\n\n        if (snapDelta >= snapThreshold && snapDelta > 0) {\n          // Move to anchor at position\n          targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);\n        } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {\n          // Move to the adjacent panel\n          targetAnchor = this._findAdjacentAnchor(posDelta, anchorAtCamera);\n        } else {\n          // Restore to active panel\n          targetAnchor = anchorAtCamera;\n        }\n\n        this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);\n\n        return [2\n        /*return*/\n        , this._animateToPosition({\n          position: camera.clampToReachablePosition(targetAnchor.position),\n          duration: duration,\n          newActivePanel: targetAnchor.panel,\n          axesEvent: axesEvent\n        })];\n      });\n    });\n  };\n\n  __proto._findSnappedAnchor = function (position, anchorAtCamera) {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var count = this._count;\n    var currentPos = camera.position;\n    var clampedPosition = camera.clampToReachablePosition(position);\n    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtCamera || !anchorAtPosition) {\n      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE);\n    }\n\n    if (!isFinite(count)) {\n      return anchorAtPosition;\n    }\n\n    var panelCount = flicking.panelCount;\n    var anchors = camera.anchorPoints;\n    var loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);\n\n    if (position > currentPos && anchorAtPosition.index < anchorAtCamera.index || anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {\n      loopCount += 1;\n    } else if (position < currentPos && anchorAtPosition.index > anchorAtCamera.index || anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {\n      loopCount -= 1;\n    }\n\n    var circularIndexOffset = loopCount * panelCount;\n    var anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;\n\n    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {\n      var anchor = anchors[anchorAtPosition.index];\n      return new AnchorPoint({\n        index: anchor.index,\n        position: anchor.position + loopCount * camera.rangeDiff,\n        panel: anchor.panel\n      });\n    }\n\n    if (flicking.circularEnabled) {\n      var targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];\n      var loop = Math.floor(count / panelCount);\n\n      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {\n        loop += 1;\n      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {\n        loop -= 1;\n      }\n\n      return new AnchorPoint({\n        index: targetAnchor.index,\n        position: targetAnchor.position + loop * camera.rangeDiff,\n        panel: targetAnchor.panel\n      });\n    } else {\n      return anchors[clamp(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];\n    }\n  };\n\n  __proto._findAdjacentAnchor = function (posDelta, anchorAtCamera) {\n    var _a;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var adjacentAnchor = (_a = posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) !== null && _a !== void 0 ? _a : anchorAtCamera;\n    return adjacentAnchor;\n  };\n\n  __proto._calcSnapThreshold = function (position, activeAnchor) {\n    var isNextDirection = position > activeAnchor.position;\n    var panel = activeAnchor.panel;\n    var panelSize = panel.size;\n    var alignPos = panel.alignPosition; // Minimum distance needed to decide prev/next panel as nearest\n\n    /*\r\n     * |  Prev  |     Next     |\r\n     * |<------>|<------------>|\r\n     * [        |<-Anchor      ]\r\n     */\n\n    return isNextDirection ? panelSize - alignPos + panel.margin.next : alignPos + panel.margin.prev;\n  };\n\n  return SnapControl;\n}(Control);\n\n/**\r\n * A {@link Control} that can be scrolled freely without alignment\r\n * @ko     ,        {@link Control}\r\n */\n\nvar FreeControl =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(FreeControl, _super);\n  /** */\n\n\n  function FreeControl(_a) {\n    var _b = (_a === void 0 ? {} : _a).stopAtEdge,\n        stopAtEdge = _b === void 0 ? true : _b;\n\n    var _this = _super.call(this) || this;\n\n    _this._stopAtEdge = stopAtEdge;\n    return _this;\n  }\n\n  var __proto = FreeControl.prototype;\n  Object.defineProperty(__proto, \"stopAtEdge\", {\n    /**\r\n     * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\r\n     * @ko        ,     \r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._stopAtEdge;\n    },\n    set: function (val) {\n      this._stopAtEdge = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Update position after resizing\r\n   * @ko resize  position \r\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize       progress </ko>\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @chainable\r\n   * @return {Promise<void>}\r\n   */\n\n  __proto.updatePosition = function (progressInPanel) {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var activePanel = this._activePanel;\n\n    if (activePanel) {\n      var panelRange = activePanel.range;\n      var newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n      camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  };\n  /**\r\n   * Move {@link Camera} to the given position\r\n   * @ko {@link Camera}   \r\n   * @param {number} position The target position to move<ko> </ko>\r\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>     (: ms)</ko>\r\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\r\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes} {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} </ko>\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|  , Camera {@link Camera#range range}   |\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}    |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.moveToPosition = function (position, duration, axesEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, camera, targetPos, anchorAtPosition, targetPanel;\n      return __generator(this, function (_a) {\n        flicking = getFlickingAttached(this._flicking);\n        camera = flicking.camera;\n        targetPos = camera.clampToReachablePosition(position);\n        anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n        if (!anchorAtPosition) {\n          return [2\n          /*return*/\n          , Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE))];\n        }\n\n        targetPanel = anchorAtPosition.panel; // Trigger only change event\n\n        if (targetPanel !== this._activePanel) {\n          this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n        }\n\n        return [2\n        /*return*/\n        , this._animateToPosition({\n          position: this._stopAtEdge ? targetPos : position,\n          duration: duration,\n          newActivePanel: targetPanel,\n          axesEvent: axesEvent\n        })];\n      });\n    });\n  };\n\n  return FreeControl;\n}(Control);\n\n/**\r\n * A {@link Control} that allow you to select the maximum number of panels to move at a time\r\n * @ko        {@link Control}\r\n */\n\nvar StrictControl =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(StrictControl, _super);\n  /** */\n\n\n  function StrictControl(_a) {\n    var _b = (_a === void 0 ? {} : _a).count,\n        count = _b === void 0 ? 1 : _b;\n\n    var _this = _super.call(this) || this;\n\n    _this.setActive = function (newActivePanel, prevActivePanel, isTrusted) {\n      _super.prototype.setActive.call(_this, newActivePanel, prevActivePanel, isTrusted);\n\n      _this.updateInput();\n    };\n\n    _this._count = count;\n\n    _this._resetIndexRange();\n\n    return _this;\n  }\n\n  var __proto = StrictControl.prototype;\n  Object.defineProperty(__proto, \"count\", {\n    /**\r\n     * Maximum number of panels that can be moved at a time\r\n     * @ko      \r\n     * @type {number}\r\n     * @default 1\r\n     */\n    get: function () {\n      return this._count;\n    },\n    set: function (val) {\n      this._count = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Destroy Control and return to initial state\r\n   * @ko Control   \r\n   * @return {void}\r\n   */\n\n  __proto.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this._resetIndexRange();\n  };\n  /**\r\n   * Update {@link Control#controller controller}'s state\r\n   * @ko {@link Control#controller controller}   \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateInput = function () {\n    var _a;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var renderer = flicking.renderer;\n    var controller = this._controller;\n    var controlParams = camera.controlParams;\n    var count = this._count;\n    var activePanel = controller.state.animating ? (_a = camera.findNearestAnchor(camera.position)) === null || _a === void 0 ? void 0 : _a.panel : this._activePanel;\n\n    if (!activePanel) {\n      controller.update(controlParams);\n\n      this._resetIndexRange();\n\n      return this;\n    }\n\n    var cameraRange = controlParams.range;\n    var currentPos = activePanel.position;\n    var currentIndex = activePanel.index;\n    var panelCount = renderer.panelCount;\n    var prevPanelIndex = currentIndex - count;\n    var nextPanelIndex = currentIndex + count;\n\n    if (prevPanelIndex < 0) {\n      prevPanelIndex = flicking.circularEnabled ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount) : clamp(prevPanelIndex, 0, panelCount - 1);\n    }\n\n    if (nextPanelIndex >= panelCount) {\n      nextPanelIndex = flicking.circularEnabled ? nextPanelIndex % panelCount : clamp(nextPanelIndex, 0, panelCount - 1);\n    }\n\n    var prevPanel = renderer.panels[prevPanelIndex];\n    var nextPanel = renderer.panels[nextPanelIndex];\n    var prevPos = Math.max(prevPanel.position, cameraRange.min);\n    var nextPos = Math.min(nextPanel.position, cameraRange.max);\n\n    if (prevPos > currentPos) {\n      prevPos -= camera.rangeDiff;\n    }\n\n    if (nextPos < currentPos) {\n      nextPos += camera.rangeDiff;\n    }\n\n    controlParams.range = {\n      min: prevPos,\n      max: nextPos\n    };\n\n    if (controlParams.circular) {\n      if (controlParams.position < prevPos) {\n        controlParams.position += camera.rangeDiff;\n      }\n\n      if (controlParams.position > nextPos) {\n        controlParams.position -= camera.rangeDiff;\n      }\n    }\n\n    controlParams.circular = false;\n    controller.update(controlParams);\n    this._indexRange = {\n      min: prevPanel.index,\n      max: nextPanel.index\n    };\n    return this;\n  };\n  /**\r\n   * Move {@link Camera} to the given position\r\n   * @ko {@link Camera}   \r\n   * @param {number} position The target position to move<ko> </ko>\r\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>     (: ms)</ko>\r\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\r\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes} {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} </ko>\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|  , Camera {@link Camera#range range}   |\r\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}    |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.moveToPosition = function (position, duration, axesEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, camera, activePanel, axesRange, indexRange, cameraRange, clampedPosition, anchorAtPosition, prevPos, isOverThreshold, adjacentAnchor, targetPos, targetPanel, anchors, firstAnchor, lastAnchor, shouldBounceToFirst, shouldBounceToLast, targetAnchor;\n      return __generator(this, function (_a) {\n        flicking = getFlickingAttached(this._flicking);\n        camera = flicking.camera;\n        activePanel = this._activePanel;\n        axesRange = this._controller.range;\n        indexRange = this._indexRange;\n        cameraRange = camera.range;\n        clampedPosition = clamp(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);\n        anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n        if (!anchorAtPosition || !activePanel) {\n          return [2\n          /*return*/\n          , Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE))];\n        }\n\n        prevPos = activePanel.position;\n        isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n        adjacentAnchor = position > prevPos ? camera.getNextAnchor(anchorAtPosition) : camera.getPrevAnchor(anchorAtPosition);\n        anchors = camera.anchorPoints;\n        firstAnchor = anchors[0];\n        lastAnchor = anchors[anchors.length - 1];\n        shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);\n        shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);\n\n        if (shouldBounceToFirst || shouldBounceToLast) {\n          targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;\n          targetPanel = targetAnchor.panel;\n          targetPos = targetAnchor.position;\n        } else if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n          // Move to anchor at position\n          targetPanel = anchorAtPosition.panel;\n          targetPos = anchorAtPosition.position;\n        } else if (isOverThreshold && adjacentAnchor && isBetween(adjacentAnchor.index, indexRange.min, indexRange.max)) {\n          // Move to adjacent anchor\n          targetPanel = adjacentAnchor.panel;\n          targetPos = adjacentAnchor.position;\n        } else {\n          // Restore to active panel\n          targetPos = camera.clampToReachablePosition(activePanel.position);\n          targetPanel = activePanel;\n        }\n\n        this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n        return [2\n        /*return*/\n        , this._animateToPosition({\n          position: targetPos,\n          duration: duration,\n          newActivePanel: targetPanel,\n          axesEvent: axesEvent\n        })];\n      });\n    });\n  };\n\n  __proto._resetIndexRange = function () {\n    this._indexRange = {\n      min: 0,\n      max: 0\n    };\n  };\n\n  return StrictControl;\n}(Control);\n\n/**\r\n * A mode of camera\r\n */\n\nvar CameraMode =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function CameraMode(flicking) {\n    this._flicking = flicking;\n  }\n\n  var __proto = CameraMode.prototype;\n\n  __proto.getAnchors = function () {\n    var panels = this._flicking.renderer.panels;\n    return panels.map(function (panel, index) {\n      return new AnchorPoint({\n        index: index,\n        position: panel.position,\n        panel: panel\n      });\n    });\n  };\n\n  __proto.findAnchorIncludePosition = function (position) {\n    var anchors = this._flicking.camera.anchorPoints;\n    var anchorsIncludingPosition = anchors.filter(function (anchor) {\n      return anchor.panel.includePosition(position, true);\n    });\n    return anchorsIncludingPosition.reduce(function (nearest, anchor) {\n      if (!nearest) return anchor;\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;\n    }, null);\n  };\n\n  __proto.clampToReachablePosition = function (position) {\n    var camera = this._flicking.camera;\n    var range = camera.range;\n    return clamp(position, range.min, range.max);\n  };\n\n  __proto.getCircularOffset = function () {\n    return 0;\n  };\n\n  __proto.canReach = function (panel) {\n    var camera = this._flicking.camera;\n    var range = camera.range;\n    if (panel.removed) return false;\n    var panelPos = panel.position;\n    return panelPos >= range.min && panelPos <= range.max;\n  };\n\n  __proto.canSee = function (panel) {\n    var camera = this._flicking.camera;\n    var visibleRange = camera.visibleRange; // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n\n    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);\n  };\n\n  return CameraMode;\n}();\n\nvar LinearCameraMode =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(LinearCameraMode, _super);\n\n  function LinearCameraMode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = LinearCameraMode.prototype;\n\n  __proto.checkAvailability = function () {\n    // It's always available\n    return true;\n  };\n\n  __proto.getRange = function () {\n    var _a, _b;\n\n    var renderer = this._flicking.renderer;\n    var firstPanel = renderer.getPanel(0);\n    var lastPanel = renderer.getPanel(renderer.panelCount - 1);\n    return {\n      min: (_a = firstPanel === null || firstPanel === void 0 ? void 0 : firstPanel.position) !== null && _a !== void 0 ? _a : 0,\n      max: (_b = lastPanel === null || lastPanel === void 0 ? void 0 : lastPanel.position) !== null && _b !== void 0 ? _b : 0\n    };\n  };\n\n  return LinearCameraMode;\n}(CameraMode);\n\n/**\r\n * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop\r\n * @ko      ,      {@link Camera} \r\n */\n\nvar CircularCameraMode =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(CircularCameraMode, _super);\n\n  function CircularCameraMode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = CircularCameraMode.prototype;\n\n  __proto.checkAvailability = function () {\n    var flicking = this._flicking;\n    var renderer = flicking.renderer;\n    var panels = renderer.panels;\n\n    if (panels.length <= 0) {\n      return false;\n    }\n\n    var firstPanel = panels[0];\n    var lastPanel = panels[panels.length - 1];\n    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n    var visibleSize = flicking.camera.size;\n    var panelSizeSum = lastPanelNext - firstPanelPrev;\n    var canSetCircularMode = panels.every(function (panel) {\n      return panelSizeSum - panel.size >= visibleSize;\n    });\n    return canSetCircularMode;\n  };\n\n  __proto.getRange = function () {\n    var flicking = this._flicking;\n    var panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return {\n        min: 0,\n        max: 0\n      };\n    }\n\n    var firstPanel = panels[0];\n    var lastPanel = panels[panels.length - 1];\n    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n    return {\n      min: firstPanelPrev,\n      max: lastPanelNext\n    };\n  };\n\n  __proto.getAnchors = function () {\n    var flicking = this._flicking;\n    var panels = flicking.renderer.panels;\n    return panels.map(function (panel, index) {\n      return new AnchorPoint({\n        index: index,\n        position: panel.position,\n        panel: panel\n      });\n    });\n  };\n\n  __proto.findAnchorIncludePosition = function (position) {\n    var camera = this._flicking.camera;\n    var range = camera.range;\n    var anchors = camera.anchorPoints;\n    var rangeDiff = camera.rangeDiff;\n    var anchorCount = anchors.length;\n    var positionInRange = circulatePosition(position, range.min, range.max);\n\n    var anchorInRange = _super.prototype.findAnchorIncludePosition.call(this, positionInRange);\n\n    if (anchorCount > 0 && (position === range.min || position === range.max)) {\n      var possibleAnchors = [anchorInRange, new AnchorPoint({\n        index: 0,\n        position: anchors[0].position + rangeDiff,\n        panel: anchors[0].panel\n      }), new AnchorPoint({\n        index: anchorCount - 1,\n        position: anchors[anchorCount - 1].position - rangeDiff,\n        panel: anchors[anchorCount - 1].panel\n      })].filter(function (anchor) {\n        return !!anchor;\n      });\n      anchorInRange = possibleAnchors.reduce(function (nearest, anchor) {\n        if (!nearest) return anchor;\n        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;\n      }, null);\n    }\n\n    if (!anchorInRange) return null;\n\n    if (position < range.min) {\n      var loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      var loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  };\n\n  __proto.getCircularOffset = function () {\n    var flicking = this._flicking;\n    var camera = flicking.camera;\n    if (!camera.circularEnabled) return 0;\n    var toggled = flicking.panels.filter(function (panel) {\n      return panel.toggled;\n    });\n    var toggledPrev = toggled.filter(function (panel) {\n      return panel.toggleDirection === DIRECTION.PREV;\n    });\n    var toggledNext = toggled.filter(function (panel) {\n      return panel.toggleDirection === DIRECTION.NEXT;\n    });\n    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  };\n\n  __proto.clampToReachablePosition = function (position) {\n    // Basically all position is reachable for circular camera\n    return position;\n  };\n\n  __proto.canReach = function (panel) {\n    if (panel.removed) return false; // Always reachable on circular mode\n\n    return true;\n  };\n\n  __proto.canSee = function (panel) {\n    var camera = this._flicking.camera;\n    var range = camera.range;\n    var rangeDiff = camera.rangeDiff;\n    var visibleRange = camera.visibleRange;\n\n    var visibleInCurrentRange = _super.prototype.canSee.call(this, panel); // Check looped visible area for circular case\n\n\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);\n    }\n\n    return visibleInCurrentRange;\n  };\n\n  __proto._calcPanelAreaSum = function (panels) {\n    return panels.reduce(function (sum, panel) {\n      return sum + panel.sizeIncludingMargin;\n    }, 0);\n  };\n\n  return CircularCameraMode;\n}(CameraMode);\n\nvar BoundCameraMode =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(BoundCameraMode, _super);\n\n  function BoundCameraMode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = BoundCameraMode.prototype;\n\n  __proto.checkAvailability = function () {\n    var flicking = this._flicking;\n    var renderer = flicking.renderer;\n    var firstPanel = renderer.getPanel(0);\n    var lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return false;\n    }\n\n    var viewportSize = flicking.camera.size;\n    var firstPanelPrev = firstPanel.range.min;\n    var lastPanelNext = lastPanel.range.max;\n    var panelAreaSize = lastPanelNext - firstPanelPrev;\n    var isBiggerThanViewport = viewportSize < panelAreaSize;\n    return isBiggerThanViewport;\n  };\n\n  __proto.getRange = function () {\n    var flicking = this._flicking;\n    var renderer = flicking.renderer;\n    var alignPos = flicking.camera.alignPosition;\n    var firstPanel = renderer.getPanel(0);\n    var lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return {\n        min: 0,\n        max: 0\n      };\n    }\n\n    var viewportSize = flicking.camera.size;\n    var firstPanelPrev = firstPanel.range.min;\n    var lastPanelNext = lastPanel.range.max;\n    var panelAreaSize = lastPanelNext - firstPanelPrev;\n    var isBiggerThanViewport = viewportSize < panelAreaSize;\n    var firstPos = firstPanelPrev + alignPos;\n    var lastPos = lastPanelNext - viewportSize + alignPos;\n\n    if (isBiggerThanViewport) {\n      return {\n        min: firstPos,\n        max: lastPos\n      };\n    } else {\n      var align = flicking.camera.align;\n      var alignVal = typeof align === \"object\" ? align.camera : align;\n      var pos = firstPos + parseAlign$1(alignVal, lastPos - firstPos);\n      return {\n        min: pos,\n        max: pos\n      };\n    }\n  };\n\n  __proto.getAnchors = function () {\n    var flicking = this._flicking;\n    var camera = flicking.camera;\n    var panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    var range = flicking.camera.range;\n    var reachablePanels = panels.filter(function (panel) {\n      return camera.canReach(panel);\n    });\n\n    if (reachablePanels.length > 0) {\n      var shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      var shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      var indexOffset_1 = shouldPrependBoundAnchor ? 1 : 0;\n      var newAnchors = reachablePanels.map(function (panel, idx) {\n        return new AnchorPoint({\n          index: idx + indexOffset_1,\n          position: panel.position,\n          panel: panel\n        });\n      });\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      return newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      var nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n\n      var panelAtMin = nearestPanelAtMin.index === panels.length - 1 ? nearestPanelAtMin.prev() : nearestPanelAtMin;\n      var panelAtMax = panelAtMin.next();\n      return [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: panelAtMin\n      }), new AnchorPoint({\n        index: 1,\n        position: range.max,\n        panel: panelAtMax\n      })];\n    } else {\n      return [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n  };\n\n  __proto.findAnchorIncludePosition = function (position) {\n    var camera = this._flicking.camera;\n    var range = camera.range;\n    var anchors = camera.anchorPoints;\n    if (anchors.length <= 0) return null;\n\n    if (position <= range.min) {\n      return anchors[0];\n    } else if (position >= range.max) {\n      return anchors[anchors.length - 1];\n    } else {\n      return _super.prototype.findAnchorIncludePosition.call(this, position);\n    }\n  };\n\n  __proto._findNearestPanel = function (pos, panels) {\n    var prevDist = Infinity;\n\n    for (var panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      var panel = panels[panelIdx];\n      var dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    } // Return last anchor\n\n\n    return panels[panels.length - 1];\n  };\n\n  return BoundCameraMode;\n}(CameraMode);\n\n/**\r\n * A component that manages actual movement inside the viewport\r\n * @ko      \r\n */\n\nvar Camera =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function Camera(_a) {\n    var _this = this;\n\n    var _b = (_a === void 0 ? {} : _a).align,\n        align = _b === void 0 ? ALIGN.CENTER : _b;\n\n    this._checkTranslateSupport = function () {\n      var e_1, _a;\n\n      var transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n      var supportedStyle = document.documentElement.style;\n      var transformName = \"\";\n\n      try {\n        for (var transforms_1 = __values(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {\n          var prefixedTransform = transforms_1_1.value;\n\n          if (prefixedTransform in supportedStyle) {\n            transformName = prefixedTransform;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (!transformName) {\n        throw new FlickingError(MESSAGE.TRANSFORM_NOT_SUPPORTED, CODE.TRANSFORM_NOT_SUPPORTED);\n      }\n\n      _this._transform = transformName;\n    };\n\n    this._flicking = null;\n\n    this._resetInternalValues(); // Options\n\n\n    this._align = align;\n  }\n\n  var __proto = Camera.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    // Internal states getter\n\n    /**\r\n     * The camera element(`.flicking-camera`)\r\n     * @ko  (`.flicking-camera`)\r\n     * @type {HTMLElement}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._el;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"children\", {\n    /**\r\n     * An array of the child elements of the camera element(`.flicking-camera`)\r\n     * @ko  (`.flicking-camera`)   \r\n     * @type {HTMLElement[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      return toArray(this._el.children);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"position\", {\n    /**\r\n     * Current position of the camera\r\n     * @ko Camera  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._position;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"alignPosition\", {\n    /**\r\n     * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\r\n     * @ko    .   {@link Panel} {@link Panel#alignPosition alignPosition}   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._alignPos;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"offset\", {\n    /**\r\n     * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\r\n     * @ko Camera  . {@link Flicking#renderOnlyVisible renderOnlyVisible}   .\r\n     * @type {number}\r\n     * @default 0\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._offset - this._circularOffset;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"circularEnabled\", {\n    /**\r\n     * Whether the `circular` option is enabled.\r\n     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\r\n     * @ko {@link Flicking#circular circular}      .\r\n     * {@link Flicking#circular circular}        .\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._circularEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"mode\", {\n    /**\r\n     * A current camera mode\r\n     * @type {CameraMode}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"range\", {\n    /**\r\n     * A range that Camera's {@link Camera#position position} can reach\r\n     * @ko Camera {@link Camera#position position}   \r\n     * @type {object}\r\n     * @property {number} min A minimum position<ko> </ko>\r\n     * @property {number} max A maximum position<ko> </ko>\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._range;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"rangeDiff\", {\n    /**\r\n     * A difference between Camera's minimum and maximum position that can reach\r\n     * @ko Camera   /  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._range.max - this._range.min;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"visiblePanels\", {\n    /**\r\n     * An array of visible panels from the current position\r\n     * @ko    \r\n     * @type {Panel[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._visiblePanels;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"visibleRange\", {\n    /**\r\n     * A range of the visible area from the current position\r\n     * @ko    \r\n     * @type {object}\r\n     * @property {number} min A minimum position<ko> </ko>\r\n     * @property {number} min A maximum position<ko> </ko>\r\n     * @readonly\r\n     */\n    get: function () {\n      return {\n        min: this._position - this._alignPos,\n        max: this._position - this._alignPos + this.size\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"anchorPoints\", {\n    /**\r\n     * An array of {@link AnchorPoint}s that Camera can be stopped at\r\n     * @ko    {@link AnchorPoint} \r\n     * @type {AnchorPoint[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._anchors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"controlParams\", {\n    /**\r\n     * A current parameters of the Camera for updating {@link AxesController}\r\n     * @ko {@link AxesController}    Camera \r\n     * @type {ControlParams}\r\n     * @readonly\r\n     */\n    get: function () {\n      return {\n        range: this._range,\n        position: this._position,\n        circular: this._circularEnabled\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"atEdge\", {\n    /**\r\n     * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\r\n     * @ko          \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._position <= this._range.min || this._position >= this._range.max;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"size\", {\n    /**\r\n     * Return the size of the viewport\r\n     * @ko   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var flicking = this._flicking;\n      return flicking ? flicking.horizontal ? flicking.viewport.width : flicking.viewport.height : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"progress\", {\n    /**\r\n     * Return the camera's position progress from the first panel to last panel\r\n     * Range is from 0 to last panel's index\r\n     * @ko        \r\n     *  0   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var flicking = this._flicking;\n      var position = this._position + this._offset;\n      var nearestAnchor = this.findNearestAnchor(this._position);\n\n      if (!flicking || !nearestAnchor) {\n        return NaN;\n      }\n\n      var nearestPanel = nearestAnchor.panel;\n      var panelPos = nearestPanel.position + nearestPanel.offset;\n      var bounceSize = flicking.control.controller.bounce;\n      var _a = this.range,\n          prevRange = _a.min,\n          nextRange = _a.max;\n      var rangeDiff = this.rangeDiff;\n\n      if (position === panelPos) {\n        return nearestPanel.index;\n      }\n\n      if (position < panelPos) {\n        var prevPanel = nearestPanel.prev();\n        var prevPosition = prevPanel ? prevPanel.position + prevPanel.offset : prevRange - bounceSize[0]; // Looped\n\n        if (prevPosition > panelPos) {\n          prevPosition -= rangeDiff;\n        }\n\n        return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n      } else {\n        var nextPanel = nearestPanel.next();\n        var nextPosition = nextPanel ? nextPanel.position + nextPanel.offset : nextRange + bounceSize[1]; // Looped\n\n        if (nextPosition < panelPos) {\n          nextPosition += rangeDiff;\n        }\n\n        return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"align\", {\n    // Options Getter\n\n    /**\r\n     * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\r\n     * @ko {@link Camera#alignPosition alignPosition}        \r\n     * @type {ALIGN | string | number}\r\n     */\n    get: function () {\n      return this._align;\n    },\n    // Options Setter\n    set: function (val) {\n      this._align = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize Camera\r\n   * @ko Camera \r\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking </ko>\r\n   * @chainable\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\r\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL}     (`.flicking-camera`)   </ko>\r\n   * @return {this}\r\n   */\n\n  __proto.init = function (flicking) {\n    this._flicking = flicking;\n    var viewportEl = flicking.viewport.element;\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild;\n\n    this._checkTranslateSupport();\n\n    this._updateMode();\n\n    return this;\n  };\n  /**\r\n   * Destroy Camera and return to initial state\r\n   * @ko Camera   \r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    this._flicking = null;\n\n    this._resetInternalValues();\n\n    return this;\n  };\n  /**\r\n   * Move to the given position and apply CSS transform\r\n   * @ko   , CSS transform \r\n   * @param {number} pos A new position<ko> </ko>\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @return {this}\r\n   */\n\n\n  __proto.lookAt = function (pos) {\n    var _this = this;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var prevPos = this._position;\n    this._position = pos;\n\n    var toggled = this._togglePanels(prevPos, pos);\n\n    this._refreshVisiblePanels();\n\n    this._checkNeedPanel();\n\n    this._checkReachEnd(prevPos, pos);\n\n    this.applyTransform();\n\n    if (toggled) {\n      void flicking.renderer.render().then(function () {\n        _this.updateOffset();\n      });\n    }\n  };\n  /**\r\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\r\n   * If it does not exist, return `null` instead\r\n   * @ko  {@link AnchorPoint}  {@link AnchorPoint} \r\n   *    `null` \r\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko> {@link AnchorPoint}</ko>\r\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko> {@link AnchorPoint}</ko>\r\n   */\n\n\n  __proto.getPrevAnchor = function (anchor) {\n    if (!this._circularEnabled || anchor.index !== 0) {\n      return this._anchors[anchor.index - 1] || null;\n    } else {\n      var anchors = this._anchors;\n      var rangeDiff = this.rangeDiff;\n      var lastAnchor = anchors[anchors.length - 1];\n      return new AnchorPoint({\n        index: lastAnchor.index,\n        position: lastAnchor.position - rangeDiff,\n        panel: lastAnchor.panel\n      });\n    }\n  };\n  /**\r\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\r\n   * If it does not exist, return `null` instead\r\n   * @ko  {@link AnchorPoint}  {@link AnchorPoint} \r\n   *    `null` \r\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko> {@link AnchorPoint}</ko>\r\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko> {@link AnchorPoint}</ko>\r\n   */\n\n\n  __proto.getNextAnchor = function (anchor) {\n    var anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {\n      return anchors[anchor.index + 1] || null;\n    } else {\n      var rangeDiff = this.rangeDiff;\n      var firstAnchor = anchors[0];\n      return new AnchorPoint({\n        index: firstAnchor.index,\n        position: firstAnchor.position + rangeDiff,\n        panel: firstAnchor.panel\n      });\n    }\n  };\n  /**\r\n   * Return the camera's position progress in the panel below\r\n   * Value is from 0 to 1 when the camera's inside panel\r\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\r\n   * @ko       \r\n   *       0 1  \r\n   *  margin    0  1     \r\n   */\n\n\n  __proto.getProgressInPanel = function (panel) {\n    var panelRange = panel.range;\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  };\n  /**\r\n   * Return {@link AnchorPoint} that includes given position\r\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\r\n   * @ko    {@link AnchorPoint} \r\n   *    {@link AnchorPoint}   `null` \r\n   * @param {number} position A position to check<ko> </ko>\r\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>   {@link AnchorPoint}</ko>\r\n   */\n\n\n  __proto.findAnchorIncludePosition = function (position) {\n    return this._mode.findAnchorIncludePosition(position);\n  };\n  /**\r\n   * Return {@link AnchorPoint} nearest to given position\r\n   * If there're no {@link AnchorPoint}s, return `null` instead\r\n   * @ko     {@link AnchorPoint} \r\n   * {@link AnchorPoint}    `null` \r\n   * @param {number} position A position to check<ko> </ko>\r\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>    {@link AnchorPoint}</ko>\r\n   */\n\n\n  __proto.findNearestAnchor = function (position) {\n    var anchors = this._anchors;\n    if (anchors.length <= 0) return null;\n    var prevDist = Infinity;\n\n    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      var anchor = anchors[anchorIdx];\n      var dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    } // Return last anchor\n\n\n    return anchors[anchors.length - 1];\n  };\n  /**\r\n   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}\r\n   * @ko  {@link Flicking#currentPanel}  {@link AnchorPoint} \r\n   * @return {AnchorPoint | null}\r\n   */\n\n\n  __proto.findActiveAnchor = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var activeIndex = flicking.control.activeIndex;\n    return find(this._anchors, function (anchor) {\n      return anchor.panel.index === activeIndex;\n    });\n  };\n  /**\r\n   * Clamp the given position between camera's range\r\n   * @ko   Camera      \r\n   * @param {number} position A position to clamp<ko>  </ko>\r\n   * @return {number} A clamped position<ko>  </ko>\r\n   */\n\n\n  __proto.clampToReachablePosition = function (position) {\n    return this._mode.clampToReachablePosition(position);\n  };\n  /**\r\n   * Check whether the given panel is inside of the Camera's range\r\n   * @ko  {@link Panel} Camera      \r\n   * @param panel An instance of {@link Panel} to check<ko> {@link Panel} </ko>\r\n   * @return {boolean} Whether the panel's inside Camera's range<ko>       </ko>\r\n   */\n\n\n  __proto.canReach = function (panel) {\n    return this._mode.canReach(panel);\n  };\n  /**\r\n   * Check whether the given panel element is visible at the current position\r\n   * @ko          \r\n   * @param panel An instance of {@link Panel} to check<ko> {@link Panel} </ko>\r\n   * @return Whether the panel element is visible at the current position<ko>      </ko>\r\n   */\n\n\n  __proto.canSee = function (panel) {\n    return this._mode.canSee(panel);\n  };\n  /**\r\n   * Update {@link Camera#range range} of Camera\r\n   * @ko Camera {@link Camera#range range} \r\n   * @method\r\n   * @abstract\r\n   * @memberof Camera\r\n   * @instance\r\n   * @name updateRange\r\n   * @chainable\r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateRange = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var renderer = flicking.renderer;\n    var panels = renderer.panels;\n\n    this._updateMode();\n\n    this._range = this._mode.getRange();\n\n    if (this._circularEnabled) {\n      panels.forEach(function (panel) {\n        return panel.updateCircularToggleDirection();\n      });\n    }\n\n    this.updateOffset();\n    return this;\n  };\n  /**\r\n   * Update Camera's {@link Camera#alignPosition alignPosition}\r\n   * @ko Camera {@link Camera#alignPosition alignPosition} \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateAlignPos = function () {\n    var align = this._align;\n    var alignVal = typeof align === \"object\" ? align.camera : align;\n    this._alignPos = parseAlign$1(alignVal, this.size);\n    return this;\n  };\n  /**\r\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\r\n   * @ko Camera {@link Camera#anchorPoints anchorPoints} \r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateAnchors = function () {\n    this._anchors = this._mode.getAnchors();\n    return this;\n  };\n  /**\r\n   * Update Viewport's height to active panel's height\r\n   * @ko        \r\n   * @throws {FlickingError}\r\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\r\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}    </ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateAdaptiveHeight = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var activePanel = flicking.control.activePanel;\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  };\n  /**\r\n   * Update current offset of the camera\r\n   * @ko    \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updateOffset = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var position = this._position;\n    var unRenderedPanels = flicking.panels.filter(function (panel) {\n      return !panel.rendered;\n    });\n    this._offset = unRenderedPanels.filter(function (panel) {\n      return panel.position + panel.offset < position;\n    }).reduce(function (offset, panel) {\n      return offset + panel.sizeIncludingMargin;\n    }, 0);\n    this._circularOffset = this._mode.getCircularOffset();\n    this.applyTransform();\n    return this;\n  };\n  /**\r\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\r\n   * @ko  {@link Flicking#event:needPanel needPanel}       \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.resetNeedPanelHistory = function () {\n    this._needPanelTriggered = {\n      prev: false,\n      next: false\n    };\n    return this;\n  };\n  /**\r\n   * Apply \"transform\" style with the current position to camera element\r\n   * @ko    transform    .\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.applyTransform = function () {\n    var el = this._el;\n    var flicking = getFlickingAttached(this._flicking);\n    var actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n    el.style[this._transform] = flicking.horizontal ? \"translate(\" + -actualPosition + \"px)\" : \"translate(0, \" + -actualPosition + \"px)\";\n    return this;\n  };\n\n  __proto._resetInternalValues = function () {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n    this._range = {\n      min: 0,\n      max: 0\n    };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = {\n      prev: false,\n      next: false\n    };\n  };\n\n  __proto._refreshVisiblePanels = function () {\n    var _this = this;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var panels = flicking.renderer.panels;\n    var newVisiblePanels = panels.filter(function (panel) {\n      return _this.canSee(panel);\n    });\n    var prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n    var added = newVisiblePanels.filter(function (panel) {\n      return !includes(prevVisiblePanels, panel);\n    });\n    var removed = prevVisiblePanels.filter(function (panel) {\n      return !includes(newVisiblePanels, panel);\n    });\n\n    if (added.length > 0 || removed.length > 0) {\n      void flicking.renderer.render().then(function () {\n        flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n          added: added,\n          removed: removed,\n          visiblePanels: newVisiblePanels\n        }));\n      });\n    }\n  };\n\n  __proto._checkNeedPanel = function () {\n    var needPanelTriggered = this._needPanelTriggered;\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n    var flicking = getFlickingAttached(this._flicking);\n    var panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, {\n          direction: DIRECTION.PREV\n        }));\n        needPanelTriggered.prev = true;\n      }\n\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, {\n          direction: DIRECTION.NEXT\n        }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    var cameraPosition = this._position;\n    var cameraSize = this.size;\n    var cameraRange = this._range;\n    var needPanelThreshold = flicking.needPanelThreshold;\n    var cameraPrev = cameraPosition - this._alignPos;\n    var cameraNext = cameraPrev + cameraSize;\n    var firstPanel = panels[0];\n    var lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      var firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= firstPanelPrev + needPanelThreshold || cameraPosition <= cameraRange.min + needPanelThreshold) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, {\n          direction: DIRECTION.PREV\n        }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      var lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= lastPanelNext - needPanelThreshold || cameraPosition >= cameraRange.max - needPanelThreshold) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, {\n          direction: DIRECTION.NEXT\n        }));\n        needPanelTriggered.next = true;\n      }\n    }\n  };\n\n  __proto._checkReachEnd = function (prevPos, newPos) {\n    var flicking = getFlickingAttached(this._flicking);\n    var range = this._range;\n    var wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    var isBetweenRange = newPos > range.min && newPos < range.max;\n    if (!wasBetweenRange || isBetweenRange) return;\n    var direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction: direction\n    }));\n  };\n\n  __proto._updateMode = function () {\n    var flicking = getFlickingAttached(this._flicking);\n\n    if (flicking.circular) {\n      var circularMode = new CircularCameraMode(flicking);\n      var canSetCircularMode = circularMode.checkAvailability();\n\n      if (canSetCircularMode) {\n        this._mode = circularMode;\n      } else {\n        var fallbackMode = flicking.circularFallback;\n        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);\n      }\n\n      this._circularEnabled = canSetCircularMode;\n    } else {\n      this._mode = flicking.bound ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);\n    }\n  };\n\n  __proto._togglePanels = function (prevPos, pos) {\n    if (pos === prevPos) return false;\n    var flicking = getFlickingAttached(this._flicking);\n    var panels = flicking.renderer.panels;\n    var toggled = panels.map(function (panel) {\n      return panel.toggle(prevPos, pos);\n    });\n    return toggled.some(function (isToggled) {\n      return isToggled;\n    });\n  };\n\n  return Camera;\n}();\n\n/**\r\n * A component that manages {@link Panel} and its elements\r\n * @ko {@link Panel}    \r\n */\n\nvar Renderer =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param {object} options An options object<ko> </ko>\r\n   * @param {Constants.ALIGN | string | number} [options.align=\"center\"] An {@link Flicking#align align} value that will be applied to all panels<ko>   {@link Flicking#align align} </ko>\r\n   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy ( )</ko>\r\n   */\n  function Renderer(_a) {\n    var _b = _a.align,\n        align = _b === void 0 ? ALIGN.CENTER : _b,\n        strategy = _a.strategy;\n    this._flicking = null;\n    this._panels = []; // Bind options\n\n    this._align = align;\n    this._strategy = strategy;\n  }\n\n  var __proto = Renderer.prototype;\n  Object.defineProperty(__proto, \"panels\", {\n    // Internal states Getter\n\n    /**\r\n     * Array of panels\r\n     * @ko   \r\n     * @type {Panel[]}\r\n     * @readonly\r\n     * @see Panel\r\n     */\n    get: function () {\n      return this._panels;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panelCount\", {\n    /**\r\n     * Count of panels\r\n     * @ko   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._panels.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"strategy\", {\n    /**\r\n     * @internal\r\n     */\n    get: function () {\n      return this._strategy;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"align\", {\n    // Options Getter\n\n    /**\r\n     * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\r\n     * @ko {@link Panel}   {@link Panel#align align} \r\n     * @type {Constants.ALIGN | string | number}\r\n     */\n    get: function () {\n      return this._align;\n    },\n    // Options Setter\n    set: function (val) {\n      this._align = val;\n      var panelAlign = parsePanelAlign(val);\n\n      this._panels.forEach(function (panel) {\n        panel.align = panelAlign;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize Renderer\r\n   * @ko Renderer \r\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking </ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n  __proto.init = function (flicking) {\n    this._flicking = flicking;\n\n    this._collectPanels();\n\n    return this;\n  };\n  /**\r\n   * Destroy Renderer and return to initial state\r\n   * @ko Renderer   \r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    this._flicking = null;\n    this._panels = [];\n  };\n  /**\r\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\r\n   * @ko    {@link Panel} .        `null` .\r\n   * @return {Panel | null} Panel at the given index<ko>   </ko>\r\n   * @see Panel\r\n   */\n\n\n  __proto.getPanel = function (index) {\n    return this._panels[index] || null;\n  };\n\n  __proto.forceRenderAllPanels = function () {\n    this._panels.forEach(function (panel) {\n      return panel.markForShow();\n    });\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Update all panel sizes\r\n   * @ko    \r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.updatePanelSize = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var panels = this._panels;\n    if (panels.length <= 0) return this;\n\n    if (flicking.panelsPerView > 0) {\n      var firstPanel = panels[0];\n      firstPanel.resize();\n\n      this._updatePanelSizeByGrid(firstPanel, panels);\n    } else {\n      flicking.panels.forEach(function (panel) {\n        return panel.resize();\n      });\n    }\n\n    return this;\n  };\n  /**\r\n   * Insert new panels at given index\r\n   * This will increase index of panels after by the number of panels added\r\n   * @ko     \r\n   *             .\r\n   * @param {Array<object>} items An array of items to insert<ko>  </ko>\r\n   * @param {number} [items.index] Index to insert new panels at<ko>   </ko>\r\n   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>       </ko>\r\n   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>  DOM    . true  ,       </ko>\r\n   * @return {Panel[]} An array of prepended panels<ko>  </ko>\r\n   */\n\n\n  __proto.batchInsert = function () {\n    var _this = this;\n\n    var items = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      items[_i] = arguments[_i];\n    }\n\n    var panels = this._panels;\n    var flicking = getFlickingAttached(this._flicking);\n    var control = flicking.control;\n    var prevFirstPanel = panels[0];\n    var align = parsePanelAlign(this._align);\n    var allPanelsInserted = items.reduce(function (addedPanels, item) {\n      var _a;\n\n      var insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      var panelsPushed = panels.slice(insertingIdx);\n      var panelsInserted = item.elements.map(function (el, idx) {\n        return _this._createPanel(el, {\n          index: insertingIdx + idx,\n          align: align,\n          flicking: flicking\n        });\n      });\n      panels.splice.apply(panels, __spread([insertingIdx, 0], panelsInserted));\n\n      if (item.hasDOMInElements) {\n        // Insert the actual elements as camera element's children\n        _this._insertPanelElements(panelsInserted, (_a = panelsPushed[0]) !== null && _a !== void 0 ? _a : null);\n      } // Resize the newly added panels\n\n\n      if (flicking.panelsPerView > 0) {\n        var firstPanel = prevFirstPanel || panelsInserted[0].resize();\n\n        _this._updatePanelSizeByGrid(firstPanel, panelsInserted);\n      } else {\n        panelsInserted.forEach(function (panel) {\n          return panel.resize();\n        });\n      } // Update panel indexes & positions\n\n\n      panelsPushed.forEach(function (panel) {\n        panel.increaseIndex(panelsInserted.length);\n        panel.updatePosition();\n      });\n      return __spread(addedPanels, panelsInserted);\n    }, []);\n    if (allPanelsInserted.length <= 0) return []; // Update camera & control\n\n    this._updateCameraAndControl();\n\n    void this.render(); // Move to the first panel added if no panels existed\n    // FIXME: fix for animating case\n\n    if (allPanelsInserted.length > 0 && !control.animating) {\n      void control.moveToPanel(control.activePanel || allPanelsInserted[0], {\n        duration: 0\n      }).catch(function () {\n        return void 0;\n      });\n    }\n\n    flicking.camera.updateOffset();\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: allPanelsInserted,\n      removed: []\n    }));\n    this.checkPanelContentsReady(allPanelsInserted);\n    return allPanelsInserted;\n  };\n  /**\r\n   * Remove the panel at the given index\r\n   * This will decrease index of panels after by the number of panels removed\r\n   * @ko    \r\n   *            \r\n   * @param {Array<object>} items An array of items to remove<ko>  </ko>\r\n   * @param {number} [items.index] Index of panel to remove<ko>  </ko>\r\n   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index`    </ko>\r\n   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>  DOM    . true  ,       </ko>\r\n   * @return An array of removed panels<ko>  </ko>\r\n   */\n\n\n  __proto.batchRemove = function () {\n    var _this = this;\n\n    var items = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      items[_i] = arguments[_i];\n    }\n\n    var panels = this._panels;\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera,\n        control = flicking.control;\n    var activePanel = control.activePanel;\n    var activeIndex = control.activeIndex;\n    var allPanelsRemoved = items.reduce(function (removed, item) {\n      var index = item.index,\n          deleteCount = item.deleteCount;\n      var removingIdx = getMinusCompensatedIndex(index, panels.length);\n      var panelsPulled = panels.slice(removingIdx + deleteCount);\n      var panelsRemoved = panels.splice(removingIdx, deleteCount);\n      if (panelsRemoved.length <= 0) return []; // Update panel indexes & positions\n\n      panelsPulled.forEach(function (panel) {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.updatePosition();\n      });\n\n      if (item.hasDOMInElements) {\n        _this._removePanelElements(panelsRemoved);\n      } // Remove panel elements\n\n\n      panelsRemoved.forEach(function (panel) {\n        return panel.destroy();\n      });\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return __spread(removed, panelsRemoved);\n    }, []); // Update camera & control\n\n    this._updateCameraAndControl();\n\n    void this.render(); // FIXME: fix for animating case\n\n    if (allPanelsRemoved.length > 0 && !control.animating) {\n      var targetPanel = includes(allPanelsRemoved, activePanel) ? panels[activeIndex] || panels[panels.length - 1] : activePanel;\n\n      if (targetPanel) {\n        void control.moveToPanel(targetPanel, {\n          duration: 0\n        }).catch(function () {\n          return void 0;\n        });\n      } else {\n        // All panels removed\n        camera.lookAt(0);\n      }\n    }\n\n    flicking.camera.updateOffset();\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: [],\n      removed: allPanelsRemoved\n    }));\n    return allPanelsRemoved;\n  };\n  /**\r\n   * @internal\r\n   */\n\n\n  __proto.checkPanelContentsReady = function (checkingPanels) {\n    var _this = this;\n\n    var flicking = getFlickingAttached(this._flicking);\n    var resizeOnContentsReady = flicking.resizeOnContentsReady;\n    var panels = this._panels;\n    if (!resizeOnContentsReady || flicking.virtualEnabled) return;\n\n    var hasContents = function (panel) {\n      return !!panel.element.querySelector(\"img, video\");\n    };\n\n    checkingPanels = checkingPanels.filter(function (panel) {\n      return hasContents(panel);\n    });\n    if (checkingPanels.length <= 0) return;\n    var contentsReadyChecker = new ImReady();\n    checkingPanels.forEach(function (panel) {\n      panel.loading = true;\n    });\n    contentsReadyChecker.on(\"readyElement\", function (e) {\n      if (!_this._flicking) {\n        // Renderer's destroy() is called before\n        contentsReadyChecker.destroy();\n        return;\n      }\n\n      var panel = checkingPanels[e.index];\n      var camera = flicking.camera;\n      var control = flicking.control;\n      var prevProgressInPanel = control.activePanel ? camera.getProgressInPanel(control.activePanel) : 0;\n      panel.loading = false;\n      panel.resize();\n      panels.slice(panel.index + 1).forEach(function (panelBehind) {\n        return panelBehind.updatePosition();\n      });\n      if (!flicking.initialized) return;\n      camera.updateRange();\n      camera.updateAnchors();\n\n      if (control.animating) ; else {\n        control.updatePosition(prevProgressInPanel);\n        control.updateInput();\n      }\n    });\n    contentsReadyChecker.on(\"preReady\", function (e) {\n      if (_this._flicking) {\n        void _this.render();\n      }\n\n      if (e.readyCount === e.totalCount) {\n        contentsReadyChecker.destroy();\n      }\n    });\n    contentsReadyChecker.on(\"ready\", function () {\n      if (_this._flicking) {\n        void _this.render();\n      }\n\n      contentsReadyChecker.destroy();\n    });\n    contentsReadyChecker.check(checkingPanels.map(function (panel) {\n      return panel.element;\n    }));\n  };\n\n  __proto._updateCameraAndControl = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera,\n        control = flicking.control;\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  };\n\n  __proto._showOnlyVisiblePanels = function (flicking) {\n    var panels = flicking.renderer.panels;\n    var camera = flicking.camera;\n    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n    panels.forEach(function (panel) {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n  };\n\n  __proto._updatePanelSizeByGrid = function (referencePanel, panels) {\n    var flicking = getFlickingAttached(this._flicking);\n    var panelsPerView = flicking.panelsPerView;\n\n    if (panelsPerView <= 0) {\n      throw new FlickingError(MESSAGE.WRONG_OPTION(\"panelsPerView\", panelsPerView), CODE.WRONG_OPTION);\n    }\n\n    if (panels.length <= 0) return;\n    var viewportSize = flicking.camera.size;\n    var gap = referencePanel.margin.prev + referencePanel.margin.next;\n    var panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;\n    var panelSizeObj = flicking.horizontal ? {\n      width: panelSize\n    } : {\n      height: panelSize\n    };\n    var firstPanelSizeObj = {\n      size: panelSize,\n      height: referencePanel.height,\n      margin: referencePanel.margin\n    };\n\n    if (!flicking.noPanelStyleOverride) {\n      this._strategy.updatePanelSizes(flicking, panelSizeObj);\n    }\n\n    flicking.panels.forEach(function (panel) {\n      return panel.resize(firstPanelSizeObj);\n    });\n  };\n\n  __proto._removeAllChildsFromCamera = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var cameraElement = flicking.camera.element; // Remove other elements\n\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  };\n\n  __proto._insertPanelElements = function (panels, nextSibling) {\n    if (nextSibling === void 0) {\n      nextSibling = null;\n    }\n\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n    var cameraElement = camera.element;\n    var nextSiblingElement = (nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.element) || null;\n    var fragment = document.createDocumentFragment();\n    panels.forEach(function (panel) {\n      return fragment.appendChild(panel.element);\n    });\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n  };\n\n  __proto._removePanelElements = function (panels) {\n    var flicking = getFlickingAttached(this._flicking);\n    var cameraElement = flicking.camera.element;\n    panels.forEach(function (panel) {\n      cameraElement.removeChild(panel.element);\n    });\n  };\n\n  return Renderer;\n}();\n\n/**\r\n *\r\n */\n\nvar VanillaRenderer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(VanillaRenderer, _super);\n\n  function VanillaRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  var __proto = VanillaRenderer.prototype;\n\n  __proto.render = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var flicking, strategy;\n      return __generator(this, function (_a) {\n        flicking = getFlickingAttached(this._flicking);\n        strategy = this._strategy;\n        strategy.updateRenderingPanels(flicking);\n        strategy.renderPanels(flicking);\n\n        this._resetPanelElementOrder();\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  __proto._collectPanels = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var camera = flicking.camera;\n\n    this._removeAllTextNodes();\n\n    this._panels = this._strategy.collectPanels(flicking, camera.children);\n  };\n\n  __proto._createPanel = function (el, options) {\n    return this._strategy.createPanel(el, options);\n  };\n\n  __proto._resetPanelElementOrder = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var cameraEl = flicking.camera.element; // We're using reversed panels here as last panel should be the last element of camera element\n\n    var reversedElements = this._strategy.getRenderingElementsByOrder(flicking).reverse();\n\n    reversedElements.forEach(function (el, idx) {\n      var nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;\n\n      if (el.nextElementSibling !== nextEl) {\n        cameraEl.insertBefore(el, nextEl);\n      }\n    });\n  };\n\n  __proto._removeAllTextNodes = function () {\n    var flicking = getFlickingAttached(this._flicking);\n    var cameraElement = flicking.camera.element; // Remove all text nodes in the camera element\n\n    toArray(cameraElement.childNodes).forEach(function (node) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n  };\n\n  return VanillaRenderer;\n}(Renderer);\n\n/**\r\n * @internal\r\n */\n\nvar ExternalRenderer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ExternalRenderer, _super);\n\n  function ExternalRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n  var __proto = ExternalRenderer.prototype;\n\n  __proto._removePanelElements = function (panels) {// DO NOTHING, overrided to prevent an unexpected error\n  };\n\n  __proto._removeAllChildsFromCamera = function () {// DO NOTHING, overrided to prevent an unexpected error\n  };\n\n  return ExternalRenderer;\n}(Renderer);\n\n/**\r\n * A slide data component that holds information of a single HTMLElement\r\n * @ko   ,  HTMLElement   \r\n */\n\nvar Panel =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param {object} options An options object<ko> </ko>\r\n   * @param {number} [options.index] An initial index of the panel<ko>  </ko>\r\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>  {@link Flicking#align align}</ko>\r\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>  {@link Flicking} </ko>\r\n   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>     </ko>\r\n   */\n  function Panel(_a) {\n    var index = _a.index,\n        align = _a.align,\n        flicking = _a.flicking,\n        elementProvider = _a.elementProvider;\n    this._index = index;\n    this._flicking = flicking;\n    this._elProvider = elementProvider;\n    this._align = align;\n    this._removed = false;\n    this._rendered = true;\n    this._loading = false;\n\n    this._resetInternalStates();\n  }\n\n  var __proto = Panel.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    // Internal States Getter\n\n    /**\r\n     * `HTMLElement` that panel's referencing\r\n     * @ko    `HTMLElement`\r\n     * @type {HTMLElement}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._elProvider.element;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"elementProvider\", {\n    /**\r\n     * @internal\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._elProvider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"index\", {\n    /**\r\n     * Index of the panel\r\n     * @ko  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._index;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"position\", {\n    /**\r\n     * Position of the panel, including {@link Panel#alignPosition alignPosition}\r\n     * @ko   , {@link Panel#alignPosition alignPosition}  \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._pos + this._alignPos;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"size\", {\n    /**\r\n     * Cached size of the panel element\r\n     * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\r\n     * @ko    \r\n     *   {@link Flicking#horizontal horizontal} `true`  {@link Panel#element element} `offsetWidth` , `false`  `offsetHeight` \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"sizeIncludingMargin\", {\n    /**\r\n     * Panel's size including CSS `margin`\r\n     * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\r\n     * @ko CSS `margin`   \r\n     *   {@link Flicking#horizontal horizontal} `true`  margin left/right , `false`  margin top/bottom \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._size + this._margin.prev + this._margin.next;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"height\", {\n    /**\r\n     * Height of the panel element\r\n     * @ko   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"margin\", {\n    /**\r\n     * Cached CSS `margin` value of the panel element\r\n     * @ko   CSS `margin` \r\n     * @type {object}\r\n     * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\r\n     * <ko>{@link Flicking#horizontal horizontal} `true`  `margin-left`, `false`  `margin-top`  </ko>\r\n     * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\r\n     * <ko>{@link Flicking#horizontal horizontal} `true`  `margin-right`, `false`  `margin-bottom`  </ko>\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._margin;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"alignPosition\", {\n    /**\r\n     * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\r\n     * @ko    . {@link Camera}   {@link Camera#alignPosition alignPosition}   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._alignPos;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"removed\", {\n    /**\r\n     * A value indicating whether the panel's {@link Flicking#remove remove}d\r\n     * @ko  {@link Flicking#remove remove}   \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._removed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"rendered\", {\n    /**\r\n     * A value indicating whether the panel's element is being rendered on the screen\r\n     * @ko       \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._rendered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"loading\", {\n    /**\r\n     * A value indicating whether the panel's image/video is not loaded and waiting for resize\r\n     * @ko   /    {@link Panel#resize resize}   \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._loading;\n    },\n    set: function (val) {\n      this._loading = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"range\", {\n    /**\r\n     * Panel element's range of the bounding box\r\n     * @ko   Bounding box \r\n     * @type {object}\r\n     * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\r\n     * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\r\n     * @readonly\r\n     */\n    get: function () {\n      return {\n        min: this._pos,\n        max: this._pos + this._size\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"toggled\", {\n    /**\r\n     * A value indicating whether the panel's position is toggled by circular behavior\r\n     * @ko   circular      \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._toggled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"toggleDirection\", {\n    /**\r\n     * A direction where the panel's position is toggled\r\n     * @ko   circular    \r\n     * @type {DIRECTION}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._toggleDirection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"offset\", {\n    /**\r\n     * Actual position offset determined by {@link Panel#order}\r\n     * @ko {@link Panel#order}    \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var toggleDirection = this._toggleDirection;\n      var cameraRangeDiff = this._flicking.camera.rangeDiff;\n      return toggleDirection === DIRECTION.NONE || !this._toggled ? 0 : toggleDirection === DIRECTION.PREV ? -cameraRangeDiff : cameraRangeDiff;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"progress\", {\n    /**\r\n     * Progress of movement between previous or next panel relative to current panel\r\n     * @ko   /   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var flicking = this._flicking;\n      return this.index - flicking.camera.progress;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"outsetProgress\", {\n    /**\r\n     * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\r\n     * @ko           (prev: -1,  : 0, next: 1)\r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var position = this.position + this.offset;\n      var alignPosition = this._alignPos;\n      var camera = this._flicking.camera;\n      var camPos = camera.position;\n\n      if (camPos === position) {\n        return 0;\n      }\n\n      if (camPos < position) {\n        var disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n        return -getProgress(camPos, position, disappearPosNext);\n      } else {\n        var disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n        return 1 - getProgress(camPos, disappearPosPrev, position);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"visibleRatio\", {\n    /**\r\n     * Percentage of area where panel is visible in the viewport\r\n     * @ko      \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var range = this.range;\n      var size = this._size;\n      var offset = this.offset;\n      var visibleRange = this._flicking.camera.visibleRange;\n      var checkingRange = {\n        min: range.min + offset,\n        max: range.max + offset\n      };\n\n      if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n        return 0;\n      }\n\n      var visibleSize = size;\n\n      if (visibleRange.min > checkingRange.min) {\n        visibleSize -= visibleRange.min - checkingRange.min;\n      }\n\n      if (visibleRange.max < checkingRange.max) {\n        visibleSize -= checkingRange.max - visibleRange.max;\n      }\n\n      return visibleSize / size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"align\", {\n    // Options Getter\n\n    /**\r\n     * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\r\n     * @ko {@link Panel#alignPosition alignPosition}       \r\n     * @type {Constants.ALIGN | string | number}\r\n     */\n    get: function () {\n      return this._align;\n    },\n    // Options Setter\n    set: function (val) {\n      this._align = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Mark panel element to be appended on the camera element\r\n   * @internal\r\n   */\n\n  __proto.markForShow = function () {\n    this._rendered = true;\n\n    this._elProvider.show(this._flicking);\n  };\n  /**\r\n   * Mark panel element to be removed from the camera element\r\n   * @internal\r\n   */\n\n\n  __proto.markForHide = function () {\n    this._rendered = false;\n\n    this._elProvider.hide(this._flicking);\n  };\n  /**\r\n   * Update size of the panel\r\n   * @ko   \r\n   * @param {object} cached Predefined cached size of the panel<ko>    </ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.resize = function (cached) {\n    var el = this.element;\n    var flicking = this._flicking;\n    var horizontal = flicking.horizontal;\n\n    if (cached) {\n      this._size = cached.size;\n      this._margin = __assign({}, cached.margin);\n      this._height = cached.height;\n    } else {\n      var elStyle = getStyle(el);\n      this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n      this._margin = horizontal ? {\n        prev: parseFloat(elStyle.marginLeft || \"0\"),\n        next: parseFloat(elStyle.marginRight || \"0\")\n      } : {\n        prev: parseFloat(elStyle.marginTop || \"0\"),\n        next: parseFloat(elStyle.marginBottom || \"0\")\n      };\n      this._height = horizontal ? el.offsetHeight : this._size;\n    }\n\n    this.updatePosition();\n\n    this._updateAlignPos();\n\n    return this;\n  };\n  /**\r\n   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property\r\n   * @ko   .     CSS width/height \r\n   * @param {object} [size] New panel size<ko>  </ko>\r\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS   (px)</ko>\r\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS   (px)</ko>\r\n   * @chainable\r\n   * @return {this}\r\n   */\n\n\n  __proto.setSize = function (size) {\n    setSize(this.element, size);\n    return this;\n  };\n  /**\r\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\r\n   * @ko     {@link Panel#element element}    \r\n   * @param {HTMLElement} element The HTMLElement to check<ko>  HTMLElement</ko>\r\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko> {@link Panel#element element}    </ko>\r\n   */\n\n\n  __proto.contains = function (element) {\n    var _a;\n\n    return !!((_a = this.element) === null || _a === void 0 ? void 0 : _a.contains(element));\n  };\n  /**\r\n   * Reset internal state and set {@link Panel#removed removed} to `true`\r\n   * @ko    {@link Panel#removed removed} `true` .\r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    this._resetInternalStates();\n\n    this._removed = true;\n  };\n  /**\r\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\r\n   * @ko     {@link Panel#range range}  .\r\n   * @param {number} pos A position to check<ko>  </ko>\r\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>  {@link Panel#margin margin} </ko>\r\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>      </ko>\r\n   */\n\n\n  __proto.includePosition = function (pos, includeMargin) {\n    if (includeMargin === void 0) {\n      includeMargin = false;\n    }\n\n    return this.includeRange(pos, pos, includeMargin);\n  };\n  /**\r\n   * Check whether the given range is fully included in this panel's area (inclusive)\r\n   * @ko        \r\n   * @param {number} min Minimum value of the range to check<ko>   </ko>\r\n   * @param {number} max Maximum value of the range to check<ko>   </ko>\r\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>  {@link Panel#margin margin} </ko>\r\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>       </ko>\r\n   */\n\n\n  __proto.includeRange = function (min, max, includeMargin) {\n    if (includeMargin === void 0) {\n      includeMargin = false;\n    }\n\n    var margin = this._margin;\n    var panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  };\n  /**\r\n   * Check whether the panel is visble in the given range (exclusive)\r\n   * @ko        \r\n   * @param {number} min Minimum value of the range to check<ko>   </ko>\r\n   * @param {number} max Maximum value of the range to check<ko>   </ko>\r\n   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>       </ko>\r\n   */\n\n\n  __proto.isVisibleOnRange = function (min, max) {\n    var panelRange = this.range;\n    return max > panelRange.min && min < panelRange.max;\n  };\n  /**\r\n   * Move {@link Camera} to this panel\r\n   * @ko {@link Camera}   \r\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>   (: ms)</ko>\r\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>  resolve Promise</ko>\r\n   */\n\n\n  __proto.focus = function (duration) {\n    return this._flicking.moveTo(this._index, duration);\n  };\n  /**\r\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\r\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\r\n   * @ko (`index - 1`)  .     `null` \r\n   * {@link Flicking#circularEnabled circular}            \r\n   * @returns {Panel | null} The previous panel<ko> </ko>\r\n   */\n\n\n  __proto.prev = function () {\n    var index = this._index;\n    var flicking = this._flicking;\n    var renderer = flicking.renderer;\n    var panelCount = renderer.panelCount;\n    if (panelCount === 1) return null;\n    return flicking.circularEnabled ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1) : renderer.getPanel(index - 1);\n  };\n  /**\r\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\r\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\r\n   * @ko (`index + 1`)  .     `null` \r\n   * {@link Flicking#circularEnabled circular}            \r\n   * @returns {Panel | null} The previous panel<ko> </ko>\r\n   */\n\n\n  __proto.next = function () {\n    var index = this._index;\n    var flicking = this._flicking;\n    var renderer = flicking.renderer;\n    var panelCount = renderer.panelCount;\n    if (panelCount === 1) return null;\n    return flicking.circularEnabled ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1) : renderer.getPanel(index + 1);\n  };\n  /**\r\n   * Increase panel's index by the given value\r\n   * @ko     \r\n   * @internal\r\n   * @chainable\r\n   * @param val An integer greater than or equal to 0<ko>0   </ko>\r\n   * @returns {this}\r\n   */\n\n\n  __proto.increaseIndex = function (val) {\n    this._index += Math.max(val, 0);\n    return this;\n  };\n  /**\r\n   * Decrease panel's index by the given value\r\n   * @ko     \r\n   * @internal\r\n   * @chainable\r\n   * @param val An integer greater than or equal to 0<ko>0   </ko>\r\n   * @returns {this}\r\n   */\n\n\n  __proto.decreaseIndex = function (val) {\n    this._index -= Math.max(val, 0);\n    return this;\n  };\n  /**\r\n   * @internal\r\n   */\n\n\n  __proto.updatePosition = function () {\n    var prevPanel = this._flicking.renderer.panels[this._index - 1];\n    this._pos = prevPanel ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev : this._margin.prev;\n    return this;\n  };\n  /**\r\n   * @internal\r\n   * @return {boolean} toggled\r\n   */\n\n\n  __proto.toggle = function (prevPos, newPos) {\n    var toggleDirection = this._toggleDirection;\n    var togglePosition = this._togglePosition;\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n    var prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  };\n  /**\r\n   * @internal\r\n   */\n\n\n  __proto.updateCircularToggleDirection = function () {\n    var flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    var camera = flicking.camera;\n    var camRange = camera.range;\n    var camAlignPosition = camera.alignPosition;\n    var camVisibleRange = camera.visibleRange;\n    var camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n    var minimumVisible = camRange.min - camAlignPosition;\n    var maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n    var shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    var shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n    this._toggled = false;\n\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  };\n\n  __proto._updateAlignPos = function () {\n    this._alignPos = parseAlign$1(this._align, this._size);\n  };\n\n  __proto._resetInternalStates = function () {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = {\n      prev: 0,\n      next: 0\n    };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  };\n\n  return Panel;\n}();\n\nvar NormalRenderingStrategy =\n/*#__PURE__*/\nfunction () {\n  function NormalRenderingStrategy(_a) {\n    var providerCtor = _a.providerCtor;\n    this._providerCtor = providerCtor;\n  }\n\n  var __proto = NormalRenderingStrategy.prototype;\n\n  __proto.renderPanels = function () {// DO_NOTHING\n  };\n\n  __proto.getRenderingIndexesByOrder = function (flicking) {\n    var renderedPanels = flicking.renderer.panels.filter(function (panel) {\n      return panel.rendered;\n    });\n    var toggledPrev = renderedPanels.filter(function (panel) {\n      return panel.toggled && panel.toggleDirection === DIRECTION.PREV;\n    });\n    var toggledNext = renderedPanels.filter(function (panel) {\n      return panel.toggled && panel.toggleDirection === DIRECTION.NEXT;\n    });\n    var notToggled = renderedPanels.filter(function (panel) {\n      return !panel.toggled;\n    });\n    return __spread(toggledPrev, notToggled, toggledNext).map(function (panel) {\n      return panel.index;\n    });\n  };\n\n  __proto.getRenderingElementsByOrder = function (flicking) {\n    var panels = flicking.panels;\n    return this.getRenderingIndexesByOrder(flicking).map(function (index) {\n      return panels[index].element;\n    });\n  };\n\n  __proto.updateRenderingPanels = function (flicking) {\n    if (flicking.renderOnlyVisible) {\n      this._showOnlyVisiblePanels(flicking);\n    } else {\n      flicking.panels.forEach(function (panel) {\n        return panel.markForShow();\n      });\n    }\n  };\n\n  __proto.collectPanels = function (flicking, elements) {\n    var _this = this;\n\n    var align = parsePanelAlign(flicking.renderer.align);\n    return elements.map(function (el, index) {\n      return new Panel({\n        index: index,\n        elementProvider: new _this._providerCtor(el),\n        align: align,\n        flicking: flicking\n      });\n    });\n  };\n\n  __proto.createPanel = function (element, options) {\n    return new Panel(__assign(__assign({}, options), {\n      elementProvider: new this._providerCtor(element)\n    }));\n  };\n\n  __proto.updatePanelSizes = function (flicking, size) {\n    flicking.panels.forEach(function (panel) {\n      return panel.setSize(size);\n    });\n  };\n\n  __proto._showOnlyVisiblePanels = function (flicking) {\n    var panels = flicking.renderer.panels;\n    var camera = flicking.camera;\n    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n    panels.forEach(function (panel) {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n    camera.updateOffset();\n  };\n\n  return NormalRenderingStrategy;\n}();\n\n/**\r\n * An slide data component that holds information of a single HTMLElement\r\n * @ko   ,  HTMLElement   \r\n */\n\nvar VirtualPanel =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(VirtualPanel, _super);\n  /**\r\n   * @param {object} options An options object<ko> </ko>\r\n   * @param {number} [options.index] An initial index of the panel<ko>  </ko>\r\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>  {@link Flicking#align align}</ko>\r\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>  {@link Flicking} </ko>\r\n   */\n\n\n  function VirtualPanel(options) {\n    var _this = _super.call(this, options) || this;\n\n    options.elementProvider.init(_this);\n    _this._elProvider = options.elementProvider;\n    _this._cachedInnerHTML = null;\n    return _this;\n  }\n\n  var __proto = VirtualPanel.prototype;\n  Object.defineProperty(__proto, \"element\", {\n    /**\r\n     * `HTMLElement` that panel's referencing\r\n     * @ko    `HTMLElement`\r\n     * @type {HTMLElement}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._elProvider.element;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"cachedInnerHTML\", {\n    /**\r\n     * Cached innerHTML by the previous render function\r\n     * @ko    innerHTML \r\n     * @type {string|null}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._cachedInnerHTML;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"elementIndex\", {\n    /**\r\n     * An number for indexing which element it will be rendered on\r\n     * @ko       \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      var flicking = this._flicking;\n      var virtualElCount = flicking.panelsPerView + 1;\n      var panelCount = flicking.panelCount;\n      var index = this._index;\n\n      if (this._toggled) {\n        // To prevent element duplication\n        index = this._toggleDirection === DIRECTION.NEXT ? index + panelCount : index - panelCount;\n      }\n\n      return circulateIndex(index, virtualElCount);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.cacheRenderResult = function (result) {\n    this._cachedInnerHTML = result;\n  };\n\n  __proto.uncacheRenderResult = function () {\n    this._cachedInnerHTML = null;\n  };\n\n  __proto.render = function () {\n    var flicking = this._flicking;\n    var _a = flicking.virtual,\n        renderPanel = _a.renderPanel,\n        cache = _a.cache;\n    var element = this._elProvider.element;\n    var newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);\n    if (newInnerHTML === element.innerHTML) return;\n    element.innerHTML = newInnerHTML;\n\n    if (cache) {\n      this.cacheRenderResult(newInnerHTML);\n    }\n  };\n\n  __proto.increaseIndex = function (val) {\n    this.uncacheRenderResult();\n    return _super.prototype.increaseIndex.call(this, val);\n  };\n\n  __proto.decreaseIndex = function (val) {\n    this.uncacheRenderResult();\n    return _super.prototype.decreaseIndex.call(this, val);\n  };\n\n  return VirtualPanel;\n}(Panel);\n\nvar VirtualRenderingStrategy =\n/*#__PURE__*/\nfunction () {\n  function VirtualRenderingStrategy() {}\n\n  var __proto = VirtualRenderingStrategy.prototype;\n\n  __proto.renderPanels = function (flicking) {\n    var virtualManager = flicking.virtual;\n    var visiblePanels = flicking.visiblePanels;\n    var invisibleIndexes = range(flicking.panelsPerView + 1);\n    visiblePanels.forEach(function (panel) {\n      var elementIndex = panel.elementIndex;\n      panel.render();\n      virtualManager.show(elementIndex);\n      invisibleIndexes[elementIndex] = -1;\n    });\n    invisibleIndexes.filter(function (val) {\n      return val >= 0;\n    }).forEach(function (idx) {\n      virtualManager.hide(idx);\n    });\n  };\n\n  __proto.getRenderingIndexesByOrder = function (flicking) {\n    var virtualManager = flicking.virtual;\n\n    var visiblePanels = __spread(flicking.visiblePanels).filter(function (panel) {\n      return panel.rendered;\n    }).sort(function (panel1, panel2) {\n      return panel1.position + panel1.offset - (panel2.position + panel2.offset);\n    });\n\n    if (visiblePanels.length <= 0) return virtualManager.elements.map(function (_, idx) {\n      return idx;\n    });\n    var visibleIndexes = visiblePanels.map(function (panel) {\n      return panel.elementIndex;\n    });\n    var invisibleIndexes = virtualManager.elements.map(function (el, idx) {\n      return __assign(__assign({}, el), {\n        idx: idx\n      });\n    }).filter(function (el) {\n      return !el.visible;\n    }).map(function (el) {\n      return el.idx;\n    });\n    return __spread(visibleIndexes, invisibleIndexes);\n  };\n\n  __proto.getRenderingElementsByOrder = function (flicking) {\n    var virtualManager = flicking.virtual;\n    var elements = virtualManager.elements;\n    return this.getRenderingIndexesByOrder(flicking).map(function (index) {\n      return elements[index].nativeElement;\n    });\n  };\n\n  __proto.updateRenderingPanels = function (flicking) {\n    var panels = flicking.renderer.panels;\n    var camera = flicking.camera;\n    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n    panels.forEach(function (panel) {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else {\n        panel.markForHide();\n      }\n    });\n    camera.updateOffset();\n  };\n\n  __proto.collectPanels = function (flicking) {\n    var align = parsePanelAlign(flicking.renderer.align);\n    return range(flicking.virtual.initialPanelCount).map(function (index) {\n      return new VirtualPanel({\n        index: index,\n        elementProvider: new VirtualElementProvider(flicking),\n        align: align,\n        flicking: flicking\n      });\n    });\n  };\n\n  __proto.createPanel = function (_el, options) {\n    return new VirtualPanel(__assign(__assign({}, options), {\n      elementProvider: new VirtualElementProvider(options.flicking)\n    }));\n  };\n\n  __proto.updatePanelSizes = function (flicking, size) {\n    flicking.virtual.elements.forEach(function (el) {\n      setSize(el.nativeElement, size);\n    });\n    flicking.panels.forEach(function (panel) {\n      return panel.setSize(size);\n    });\n  };\n\n  return VirtualRenderingStrategy;\n}();\n\n/**\r\n * @extends Component\r\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\r\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\r\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\r\n */\n\nvar Flicking =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Flicking, _super);\n  /**\r\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\r\n   * <ko>Flicking  HTMLElement, `string`   css    .</ko>\r\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking   </ko>\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\r\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\r\n   * <ko>\r\n   *\r\n   * |code||\r\n   * |---|---|\r\n   * |{@link ERROR_CODE WRONG_TYPE}|  string HTMLElement  |\r\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}| CSS selector    |\r\n   *\r\n   * </ko>\r\n   * @example\r\n   * ```ts\r\n   * import Flicking from \"@egjs/flicking\";\r\n   *\r\n   * // Creating new instance of Flicking with HTMLElement\r\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\r\n   *\r\n   * // Creating new instance of Flicking with CSS selector\r\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\r\n   * ```\r\n   */\n\n\n  function Flicking(root, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.align,\n        align = _c === void 0 ? ALIGN.CENTER : _c,\n        _d = _b.defaultIndex,\n        defaultIndex = _d === void 0 ? 0 : _d,\n        _e = _b.horizontal,\n        horizontal = _e === void 0 ? true : _e,\n        _f = _b.circular,\n        circular = _f === void 0 ? false : _f,\n        _g = _b.circularFallback,\n        circularFallback = _g === void 0 ? CIRCULAR_FALLBACK.LINEAR : _g,\n        _h = _b.bound,\n        bound = _h === void 0 ? false : _h,\n        _j = _b.adaptive,\n        adaptive = _j === void 0 ? false : _j,\n        _k = _b.panelsPerView,\n        panelsPerView = _k === void 0 ? -1 : _k,\n        _l = _b.noPanelStyleOverride,\n        noPanelStyleOverride = _l === void 0 ? false : _l,\n        _m = _b.resizeOnContentsReady,\n        resizeOnContentsReady = _m === void 0 ? false : _m,\n        _o = _b.needPanelThreshold,\n        needPanelThreshold = _o === void 0 ? 0 : _o,\n        _p = _b.preventEventsBeforeInit,\n        preventEventsBeforeInit = _p === void 0 ? true : _p,\n        _q = _b.deceleration,\n        deceleration = _q === void 0 ? 0.0075 : _q,\n        _r = _b.duration,\n        duration = _r === void 0 ? 500 : _r,\n        _s = _b.easing,\n        easing = _s === void 0 ? function (x) {\n      return 1 - Math.pow(1 - x, 3);\n    } : _s,\n        _t = _b.inputType,\n        inputType = _t === void 0 ? [\"mouse\", \"touch\"] : _t,\n        _u = _b.moveType,\n        moveType = _u === void 0 ? \"snap\" : _u,\n        _v = _b.threshold,\n        threshold = _v === void 0 ? 40 : _v,\n        _w = _b.interruptable,\n        interruptable = _w === void 0 ? true : _w,\n        _x = _b.bounce,\n        bounce = _x === void 0 ? \"20%\" : _x,\n        _y = _b.iOSEdgeSwipeThreshold,\n        iOSEdgeSwipeThreshold = _y === void 0 ? 30 : _y,\n        _z = _b.preventClickOnDrag,\n        preventClickOnDrag = _z === void 0 ? true : _z,\n        _0 = _b.disableOnInit,\n        disableOnInit = _0 === void 0 ? false : _0,\n        _1 = _b.renderOnlyVisible,\n        renderOnlyVisible = _1 === void 0 ? false : _1,\n        _2 = _b.virtual,\n        virtual = _2 === void 0 ? null : _2,\n        _3 = _b.autoInit,\n        autoInit = _3 === void 0 ? true : _3,\n        _4 = _b.autoResize,\n        autoResize = _4 === void 0 ? true : _4,\n        _5 = _b.useResizeObserver,\n        useResizeObserver = _5 === void 0 ? true : _5,\n        _6 = _b.externalRenderer,\n        externalRenderer = _6 === void 0 ? null : _6,\n        _7 = _b.renderExternal,\n        renderExternal = _7 === void 0 ? null : _7;\n\n    var _this = _super.call(this) || this; // Internal states\n\n\n    _this._initialized = false;\n    _this._plugins = []; // Bind options\n\n    _this._align = align;\n    _this._defaultIndex = defaultIndex;\n    _this._horizontal = horizontal;\n    _this._circular = circular;\n    _this._circularFallback = circularFallback;\n    _this._bound = bound;\n    _this._adaptive = adaptive;\n    _this._panelsPerView = panelsPerView;\n    _this._noPanelStyleOverride = noPanelStyleOverride;\n    _this._resizeOnContentsReady = resizeOnContentsReady;\n    _this._virtual = virtual;\n    _this._needPanelThreshold = needPanelThreshold;\n    _this._preventEventsBeforeInit = preventEventsBeforeInit;\n    _this._deceleration = deceleration;\n    _this._duration = duration;\n    _this._easing = easing;\n    _this._inputType = inputType;\n    _this._moveType = moveType;\n    _this._threshold = threshold;\n    _this._interruptable = interruptable;\n    _this._bounce = bounce;\n    _this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    _this._preventClickOnDrag = preventClickOnDrag;\n    _this._disableOnInit = disableOnInit;\n    _this._renderOnlyVisible = renderOnlyVisible;\n    _this._autoInit = autoInit;\n    _this._autoResize = autoResize;\n    _this._useResizeObserver = useResizeObserver;\n    _this._externalRenderer = externalRenderer;\n    _this._renderExternal = renderExternal; // Create core components\n\n    _this._viewport = new Viewport(getElement(root));\n    _this._autoResizer = new AutoResizer(_this);\n    _this._renderer = _this._createRenderer();\n    _this._camera = _this._createCamera();\n    _this._control = _this._createControl();\n    _this._virtualManager = new VirtualManager(_this, virtual);\n\n    if (_this._autoInit) {\n      void _this.init();\n    }\n\n    return _this;\n  }\n\n  var __proto = Flicking.prototype;\n  Object.defineProperty(__proto, \"control\", {\n    // Components\n\n    /**\r\n     * {@link Control} instance of the Flicking\r\n     * @ko  Flicking  {@link Control} \r\n     * @type {Control}\r\n     * @default SnapControl\r\n     * @readonly\r\n     * @see Control\r\n     * @see SnapControl\r\n     * @see FreeControl\r\n     */\n    get: function () {\n      return this._control;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"camera\", {\n    /**\r\n     * {@link Camera} instance of the Flicking\r\n     * @ko  Flicking  {@link Camera} \r\n     * @type {Camera}\r\n     * @default LinearCamera\r\n     * @readonly\r\n     * @see Camera\r\n     * @see LinearCamera\r\n     * @see BoundCamera\r\n     * @see CircularCamera\r\n     */\n    get: function () {\n      return this._camera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"renderer\", {\n    /**\r\n     * {@link Renderer} instance of the Flicking\r\n     * @ko  Flicking  {@link Renderer} \r\n     * @type {Renderer}\r\n     * @default VanillaRenderer\r\n     * @readonly\r\n     * @see Renderer\r\n     * @see VanillaRenderer\r\n     * @see ExternalRenderer\r\n     */\n    get: function () {\n      return this._renderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"viewport\", {\n    /**\r\n     * A component that manages viewport size\r\n     * @ko     \r\n     * @type {Viewport}\r\n     * @readonly\r\n     * @see Viewport\r\n     */\n    get: function () {\n      return this._viewport;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"initialized\", {\n    // Internal States\n\n    /**\r\n     * Whether Flicking's {@link Flicking#init init()} is called.\r\n     * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\r\n     * @ko Flicking {@link Flicking#init init()}    .\r\n     *   {@link Flicking#init init()}  `true` , {@link Flicking#destroy destroy()}   `false` .\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._initialized;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"circularEnabled\", {\n    /**\r\n     * Whether the `circular` option is enabled.\r\n     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\r\n     * @ko {@link Flicking#circular circular}      .\r\n     * {@link Flicking#circular circular}        .\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._camera.circularEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"virtualEnabled\", {\n    /**\r\n     * Whether the `virtual` option is enabled.\r\n     * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.\r\n     * @ko {@link Flicking#virtual virtual}      .\r\n     * {@link Flicking#virtual virtual}  {@link Flicking#panelsPerView panelsPerView}   0   .\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._panelsPerView > 0 && this._virtual != null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"index\", {\n    /**\r\n     * Index number of the {@link Flicking#currentPanel currentPanel}\r\n     * @ko {@link Flicking#currentPanel currentPanel}  \r\n     * @type {number}\r\n     * @default 0\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._control.activeIndex;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"element\", {\n    /**\r\n     * The root(`.flicking-viewport`) element\r\n     * @ko root(`.flicking-viewport`) \r\n     * @type {HTMLElement}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._viewport.element;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"currentPanel\", {\n    /**\r\n     * Currently active panel\r\n     * @ko   \r\n     * @type {Panel}\r\n     * @readonly\r\n     * @see Panel\r\n     */\n    get: function () {\n      return this._control.activePanel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panels\", {\n    /**\r\n     * Array of panels\r\n     * @ko   \r\n     * @type {Panel[]}\r\n     * @readonly\r\n     * @see Panel\r\n     */\n    get: function () {\n      return this._renderer.panels;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panelCount\", {\n    /**\r\n     * Count of panels\r\n     * @ko   \r\n     * @type {number}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._renderer.panelCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"visiblePanels\", {\n    /**\r\n     * Array of panels that is visible at the current position\r\n     * @ko    \r\n     * @type {Panel[]}\r\n     * @readonly\r\n     * @see Panel\r\n     */\n    get: function () {\n      return this._camera.visiblePanels;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"animating\", {\n    /**\r\n     * Whether Flicking's animating\r\n     * @ko    \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._control.animating;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"holding\", {\n    /**\r\n     * Whether user is clicking or touching\r\n     * @ko   / \r\n     * @type {boolean}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._control.holding;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"activePlugins\", {\n    /**\r\n     * A current list of activated plugins\r\n     * @ko    \r\n     * @type {Plugin[]}\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._plugins;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"align\", {\n    // Options Getter\n    // UI / LAYOUT\n\n    /**\r\n     * Align position of the panels within viewport. You can set different values each for the panel and camera\r\n     * @ko      .       \r\n     * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\r\n     * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko> {@link Panel}  </ko>\r\n     * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}  </ko>\r\n     * @default \"center\"\r\n     * @example\r\n     * ```ts\r\n     * const possibleOptions = [\r\n     *   // Literal strings\r\n     *   \"prev\", \"center\", \"next\",\r\n     *   // % values, applied to both panel & camera\r\n     *   \"0%\", \"25%\", \"42%\",\r\n     *   // px values, arithmetic calculation with (+/-) is also allowed.\r\n     *   \"0px\", \"100px\", \"50% - 25px\",\r\n     *   // numbers, same to number + px (\"0px\", \"100px\")\r\n     *   0, 100, 1000,\r\n     *   // Setting a different value for panel & camera\r\n     *   { panel: \"10%\", camera: \"25%\" }\r\n     * ];\r\n     *\r\n     * possibleOptions.forEach(align => {\r\n     *   new Flicking(\"#el\", { align });\r\n     * });\r\n     * ```\r\n     */\n    get: function () {\n      return this._align;\n    },\n    // Options Setter\n    // UI / LAYOUT\n    set: function (val) {\n      this._align = val;\n      this._renderer.align = val;\n      this._camera.align = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"defaultIndex\", {\n    /**\r\n     * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\r\n     * @ko Flicking {@link Flicking#init init()}      , 0  \r\n     * @type {number}\r\n     * @default 0\r\n     */\n    get: function () {\n      return this._defaultIndex;\n    },\n    set: function (val) {\n      this._defaultIndex = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"horizontal\", {\n    /**\r\n     * Direction of panel movement (true: horizontal, false: vertical)\r\n     * @ko    (true: , false: )\r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._horizontal;\n    },\n    set: function (val) {\n      this._horizontal = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"circular\", {\n    /**\r\n     * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\r\n     * @ko   .          .\r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._circular;\n    },\n    set: function (val) {\n      this._circular = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"circularFallback\", {\n    /**\r\n     * Set panel control mode for the case when circular cannot be enabled.\r\n     * \"linear\" will set the view's range from the top of the first panel to the top of the last panel.\r\n     * \"bound\" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.\r\n     * @ko           .\r\n     * \"linear\"            .\r\n     * \"bound\"             .\r\n     * @see CIRCULAR_FALLBACK\r\n     * @type {string}\r\n     * @default \"linear\"\r\n     */\n    get: function () {\n      return this._circularFallback;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"bound\", {\n    /**\r\n     * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\r\n     * Only can be enabled when `circular=false`\r\n     * @ko ( )       , /  /      \r\n     * `circular=false`    \r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._bound;\n    },\n    set: function (val) {\n      this._bound = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"adaptive\", {\n    /**\r\n     * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\r\n     * @ko          . `horizontal=true`    .\r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._adaptive;\n    },\n    set: function (val) {\n      this._adaptive = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"panelsPerView\", {\n    /**\r\n     * A visible number of panels on viewport. Enabling this option will automatically resize panel size\r\n     * @ko     .        \r\n     * @type {number}\r\n     * @default -1\r\n     */\n    get: function () {\n      return this._panelsPerView;\n    },\n    set: function (val) {\n      this._panelsPerView = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"noPanelStyleOverride\", {\n    /**\r\n     * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.\r\n     * This behavior can be useful in terms of performance when you're manually managing all panel sizes\r\n     * @ko    , {@link Flicking#panelsPerView}     `width/height`    .\r\n     *       ,       \r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._noPanelStyleOverride;\n    },\n    set: function (val) {\n      this._noPanelStyleOverride = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"resizeOnContentsReady\", {\n    /**\r\n     * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.\r\n     * This can be useful when you have contents inside Flicking that changes its size when it's loaded\r\n     * @ko    , Flicking   /    {@link Flicking#resize} .\r\n     *   Flicking   /          .\r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._resizeOnContentsReady;\n    },\n    set: function (val) {\n      this._resizeOnContentsReady = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"needPanelThreshold\", {\n    // EVENTS\n\n    /**\r\n     * A Threshold from viewport edge before triggering `needPanel` event\r\n     * @ko `needPanel`      \r\n     * @type {number}\r\n     * @default 0\r\n     */\n    get: function () {\n      return this._needPanelThreshold;\n    },\n    // EVENTS\n    set: function (val) {\n      this._needPanelThreshold = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"preventEventsBeforeInit\", {\n    /**\r\n     * When enabled, events are not triggered before `ready` when initializing\r\n     * @ko    `ready`     .\r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._preventEventsBeforeInit;\n    },\n    set: function (val) {\n      this._preventEventsBeforeInit = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"deceleration\", {\n    // ANIMATION\n\n    /**\r\n     * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\r\n     * @ko        .      \r\n     * @type {number}\r\n     * @default 0.0075\r\n     */\n    get: function () {\n      return this._deceleration;\n    },\n    // ANIMATION\n    set: function (val) {\n      this._deceleration = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"easing\", {\n    /**\r\n     * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\r\n     * @ko     easing .  `easeOutCubic`\r\n     * @type {function}\r\n     * @default x => 1 - Math.pow(1 - x, 3)\r\n     * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>  Cheat Sheet {@link http://easings.net/}</ko>\r\n     */\n    get: function () {\n      return this._easing;\n    },\n    set: function (val) {\n      this._easing = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"duration\", {\n    /**\r\n     * Default duration of the animation (ms)\r\n     * @ko     (ms)\r\n     * @type {number}\r\n     * @default 500\r\n     */\n    get: function () {\n      return this._duration;\n    },\n    set: function (val) {\n      this._duration = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"inputType\", {\n    // INPUT\n\n    /**\r\n     * Types of input devices to enable\r\n     * @ko    \r\n     * @type {string[]}\r\n     * @default [\"touch\", \"mouse\"]\r\n     * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\r\n     * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption   (PanInputOption#inputType)}</ko>\r\n     */\n    get: function () {\n      return this._inputType;\n    },\n    // INPUT\n    set: function (val) {\n      this._inputType = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"moveType\", {\n    /**\r\n     * Movement style by user input. This will change instance type of {@link Flicking#control}\r\n     * You can use the values of the constant {@link MOVE_TYPE}\r\n     * @ko     .    {@link Flicking#control}   \r\n     *  {@link MOVE_TYPE}     \r\n     * @type {MOVE_TYPE | Pair<string, object>}\r\n     * @default \"snap\"\r\n     * @example\r\n     * |moveType|control|options|\r\n     * |:---:|:---:|:---:|\r\n     * |\"snap\"|{@link SnapControl}||\r\n     * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\r\n     *\r\n     * ```ts\r\n     * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\r\n     *\r\n     * const flicking = new Flicking({\r\n     *   moveType: MOVE_TYPE.SNAP\r\n     * });\r\n     * ```\r\n     *\r\n     * ```ts\r\n     * const flicking = new Flicking({\r\n     *   // If you want more specific settings for the moveType\r\n     *   // [moveType, options for that moveType]\r\n     *   // In this case, it's [\"freeScroll\", FreeControlOptions]\r\n     *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\r\n     * });\r\n     * ```\r\n     */\n    get: function () {\n      return this._moveType;\n    },\n    set: function (val) {\n      this._moveType = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"threshold\", {\n    /**\r\n     * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\r\n     * @ko      (: px).       .\r\n     * @type {number}\r\n     * @default 40\r\n     */\n    get: function () {\n      return this._threshold;\n    },\n    set: function (val) {\n      this._threshold = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"interruptable\", {\n    /**\r\n     * Set animation to be interruptable by click/touch.\r\n     * @ko  /       .\r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._interruptable;\n    },\n    set: function (val) {\n      this._interruptable = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"bounce\", {\n    /**\r\n     * The size value of the bounce area. Only can be enabled when `circular=false`.\r\n     * You can set different bounce value for prev/next direction by using array.\r\n     * `number` for px value, and `string` for px, and % value relative to viewport size.\r\n     * You have to call {@link Control#updateInput} after changing this to take effect.\r\n     * @ko Flicking        . `circular=false`    .\r\n     *   prev/next         .\r\n     * `number`  px, `stirng`  px     %   .\r\n     *    {@link Control#updateInput}  .\r\n     * @type {string | number | Array<string | number>}\r\n     * @default \"20%\"\r\n     * @example\r\n     * ```ts\r\n     * const possibleOptions = [\r\n     *   // % values, relative to viewport element(\".flicking-viewport\")'s size\r\n     *   \"0%\", \"25%\", \"42%\",\r\n     *   // px values, arithmetic calculation with (+/-) is also allowed.\r\n     *   \"0px\", \"100px\", \"50% - 25px\",\r\n     *   // numbers, same to number + px (\"0px\", \"100px\")\r\n     *   0, 100, 1000\r\n     * ];\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\r\n     *\r\n     * flicking.bounce = \"100%\";\r\n     * flicking.control.updateInput(); // Call this to update!\r\n     * ```\r\n     */\n    get: function () {\n      return this._bounce;\n    },\n    set: function (val) {\n      this._bounce = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"iOSEdgeSwipeThreshold\", {\n    /**\r\n     * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\r\n     * @ko iOS Safari swipe  /      (px)\r\n     * @type {number}\r\n     * @default 30\r\n     */\n    get: function () {\n      return this._iOSEdgeSwipeThreshold;\n    },\n    set: function (val) {\n      this._iOSEdgeSwipeThreshold = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"preventClickOnDrag\", {\n    /**\r\n     * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\r\n     * @ko    1    {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click}  \r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._preventClickOnDrag;\n    },\n    set: function (val) {\n      var prevVal = this._preventClickOnDrag;\n      if (val === prevVal) return;\n      var controller = this._control.controller;\n\n      if (val) {\n        controller.addPreventClickHandler();\n      } else {\n        controller.removePreventClickHandler();\n      }\n\n      this._preventClickOnDrag = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"disableOnInit\", {\n    /**\r\n     * Automatically call {@link Flicking#disableInput disableInput()} on initialization\r\n     * @ko Flicking init {@link Flicking#disableInput disableInput()}  \r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._disableOnInit;\n    },\n    set: function (val) {\n      this._disableOnInit = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"renderOnlyVisible\", {\n    // PERFORMANCE\n\n    /**\r\n     * Whether to render visible panels only. This can dramatically increase performance when there're many panels\r\n     * @ko     .        \r\n     * @type {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this._renderOnlyVisible;\n    },\n    // PERFORMANCE\n    set: function (val) {\n      this._renderOnlyVisible = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"virtual\", {\n    /**\r\n     * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`\r\n     * Must be used with `panelsPerview`.\r\n     * After Flicking's initialized, this property can be used to add/remove the panel count.\r\n     * @ko        `panelsPerView + 1`  ,     .\r\n     * `panelsPerView`    .\r\n     * Flicking  ,      /    .\r\n     * @type {VirtualManager}\r\n     * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>  innerHTML  </ko>\r\n     * @property {number} initialPanelCount Initial panel count to render<ko>   </ko>\r\n     * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>  innerHTML   </ko>\r\n     * @property {string} [panelClass=\"flicking-panel\"] The class name that will be applied to rendered panel elements<ko>     </ko>\r\n     * @example\r\n     * ```ts\r\n     * import Flicking, { VirtualPanel } from \"@egjs/flicking\";\r\n     *\r\n     * const flicking = new Flicking(\"#some_el\", {\r\n     *   panelsPerView: 3,\r\n     *   virtual: {\r\n     *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,\r\n     *     initialPanelCount: 100\r\n     *   }\r\n     * });\r\n     *\r\n     * // Add 100 virtual panels (at the end)\r\n     * flicking.virtual.append(100);\r\n     *\r\n     * // Remove 100 virtual panels from 0 to 100\r\n     * flicking.virtual.remove(0, 100);\r\n     * ```\r\n     */\n    get: function () {\n      return this._virtualManager;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"autoInit\", {\n    // OTHERS\n\n    /**\r\n     * Call {@link Flicking#init init()} automatically when creating Flicking's instance\r\n     * @ko Flicking     {@link Flicking#init init()} \r\n     * @type {boolean}\r\n     * @default true\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._autoInit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"autoResize\", {\n    /**\r\n     * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed\r\n     * @ko  (.flicking-viewport)   {@link Flicking#resize resize()}     \r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._autoResize;\n    },\n    // OTHERS\n    set: function (val) {\n      this._autoResize = val;\n\n      if (val) {\n        this._autoResizer.enable();\n      } else {\n        this._autoResizer.disable();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"useResizeObserver\", {\n    /**\r\n     * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option\r\n     * @ko autoResize   {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}  Window {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize}     \r\n     * @type {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this._useResizeObserver;\n    },\n    set: function (val) {\n      this._useResizeObserver = val;\n\n      if (this._autoResize) {\n        this._autoResizer.enable();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"externalRenderer\", {\n    /**\r\n     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\r\n     * @ko (React, Vue, Angular, ...)  ,      !\r\n     * @default null\r\n     * @internal\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._externalRenderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"renderExternal\", {\n    /**\r\n     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\r\n     * @ko (React, Vue, Angular, ...)  ,      !\r\n     * @default null\r\n     * @internal\r\n     * @readonly\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this._renderExternal;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize Flicking and move to the default index\r\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\r\n   * @ko Flicking ,   \r\n   *   `autoInit`  true(default)  Flicking    \r\n   * @fires Flicking#ready\r\n   * @return {this}\r\n   */\n\n  __proto.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var camera, renderer, control, virtualManager, originalTrigger, preventEventsBeforeInit;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._initialized) return [2\n            /*return*/\n            ];\n            camera = this._camera;\n            renderer = this._renderer;\n            control = this._control;\n            virtualManager = this._virtualManager;\n            originalTrigger = this.trigger;\n            preventEventsBeforeInit = this._preventEventsBeforeInit;\n            camera.init(this);\n            virtualManager.init();\n            renderer.init(this);\n            control.init(this);\n\n            if (preventEventsBeforeInit) {\n              this.trigger = function () {\n                return _this;\n              };\n            }\n\n            return [4\n            /*yield*/\n            , this.resize()];\n\n          case 1:\n            _a.sent(); // Look at initial panel\n\n\n            return [4\n            /*yield*/\n            , this._moveToInitialPanel()];\n\n          case 2:\n            // Look at initial panel\n            _a.sent();\n\n            if (this._autoResize) {\n              this._autoResizer.enable();\n            }\n\n            if (this._preventClickOnDrag) {\n              control.controller.addPreventClickHandler();\n            }\n\n            if (this._disableOnInit) {\n              this.disableInput();\n            }\n\n            renderer.checkPanelContentsReady(renderer.panels);\n\n            this._plugins.forEach(function (plugin) {\n              return plugin.init(_this);\n            }); // Done initializing & emit ready event\n\n\n            this._initialized = true;\n\n            if (preventEventsBeforeInit) {\n              this.trigger = originalTrigger;\n            }\n\n            this.trigger(new ComponentEvent(EVENTS.READY));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Destroy Flicking and remove all event handlers\r\n   * @ko Flicking     ,     \r\n   * @return {void}\r\n   */\n\n\n  __proto.destroy = function () {\n    this.off();\n\n    this._autoResizer.disable();\n\n    this._control.destroy();\n\n    this._camera.destroy();\n\n    this._renderer.destroy();\n\n    this._plugins.forEach(function (plugin) {\n      return plugin.destroy();\n    });\n\n    this._initialized = false;\n  };\n  /**\r\n   * Move to the previous panel (current index - 1)\r\n   * @ko    (  - 1)\r\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>     (: ms)</ko>\r\n   * @async\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|    |\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|   |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.prev = function (duration) {\n    var _a, _b, _c;\n\n    if (duration === void 0) {\n      duration = this._duration;\n    }\n\n    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.prev()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : -1, duration, DIRECTION.PREV);\n  };\n  /**\r\n   * Move to the next panel (current index + 1)\r\n   * @ko    (  + 1)\r\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>     (: ms)</ko>\r\n   * @async\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|    |\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|   |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.next = function (duration) {\n    var _a, _b, _c;\n\n    if (duration === void 0) {\n      duration = this._duration;\n    }\n\n    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.next()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : this._renderer.panelCount, duration, DIRECTION.NEXT);\n  };\n  /**\r\n   * Move to the panel with given index\r\n   * @ko     \r\n   * @param {number} index The index of the panel to move<ko>  </ko>\r\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>   (: ms)</ko>\r\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko> . {@link Flicking#circular circular}    </ko>\r\n   * @async\r\n   * @fires Flicking#moveStart\r\n   * @fires Flicking#move\r\n   * @fires Flicking#moveEnd\r\n   * @fires Flicking#willChange\r\n   * @fires Flicking#changed\r\n   * @fires Flicking#willRestore\r\n   * @fires Flicking#restored\r\n   * @fires Flicking#needPanel\r\n   * @fires Flicking#visibleChange\r\n   * @fires Flicking#reachEdge\r\n   * @throws {FlickingError}\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\r\n   * <ko>\r\n   *\r\n   * |code|condition|\r\n   * |---|---|\r\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|      |\r\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|   |\r\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|     |\r\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|    `stop()`  |\r\n   *\r\n   * </ko>\r\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>   resolve Promise</ko>\r\n   */\n\n\n  __proto.moveTo = function (index, duration, direction) {\n    if (duration === void 0) {\n      duration = this._duration;\n    }\n\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n\n    var renderer = this._renderer;\n    var panelCount = renderer.panelCount;\n    var panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(MESSAGE.ANIMATION_ALREADY_PLAYING, CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration: duration,\n      direction: direction\n    });\n  };\n  /**\r\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\r\n   * @ko    {@link Panel} .        `null` .\r\n   * @return {Panel | null} Panel at the given index<ko>   </ko>\r\n   * @see Panel\r\n   * @example\r\n   * ```ts\r\n   * const panel = flicking.getPanel(0);\r\n   * // Which is a shorthand to...\r\n   * const samePanel = flicking.panels[0];\r\n   * ```\r\n   */\n\n\n  __proto.getPanel = function (index) {\n    return this._renderer.getPanel(index);\n  };\n  /**\r\n   * Enable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @return {this}\r\n   */\n\n\n  __proto.enableInput = function () {\n    this._control.enable();\n\n    return this;\n  };\n  /**\r\n   * Disable input from the user (mouse/touch)\r\n   * @ko  (/) \r\n   * @return {this}\r\n   */\n\n\n  __proto.disableInput = function () {\n    this._control.disable();\n\n    return this;\n  };\n  /**\r\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\r\n   * @ko   .   {@link Flicking#setStatus setStatus()}        \r\n   * @param {object} options Status retrieving options<ko>Status  </ko>\r\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>    . {@link Flicking#setStatus setStatus}      </ko>\r\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>    .   {@link Flicking#moveType moveType} `freeScroll`  </ko>\r\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko> `outerHTML`  </ko>\r\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\r\n   * <ko>  ({@link Flicking#visiblePanel visiblePanel}) HTML . `includePanelHTML` `true`  .</ko>\r\n   * @return {Status} An object with current status value information<ko>    .</ko>\r\n   */\n\n\n  __proto.getStatus = function (_a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        _e = _d.index,\n        index = _e === void 0 ? true : _e,\n        _f = _d.position,\n        position = _f === void 0 ? true : _f,\n        _g = _d.includePanelHTML,\n        includePanelHTML = _g === void 0 ? false : _g,\n        _h = _d.visiblePanelsOnly,\n        visiblePanelsOnly = _h === void 0 ? false : _h;\n\n    var camera = this._camera;\n    var panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n    var status = {\n      panels: panels.map(function (panel) {\n        var panelInfo = {\n          index: panel.index\n        };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n\n    if (position) {\n      var nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n    }\n\n    if (visiblePanelsOnly) {\n      var visiblePanels = this.visiblePanels;\n      status.visibleOffset = (_c = (_b = visiblePanels[0]) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0;\n    }\n\n    return status;\n  };\n  /**\r\n   * Restore to the state of the given {@link Status}\r\n   * @ko  {@link Status}  \r\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>  . {@link Flicking#getStatus getStatus()}    </ko>\r\n   * @return {void}\r\n   */\n\n\n  __proto.setStatus = function (status) {\n    var _a;\n\n    if (!this._initialized) {\n      throw new FlickingError(MESSAGE.NOT_INITIALIZED, CODE.NOT_INITIALIZED);\n    }\n\n    var index = status.index,\n        position = status.position,\n        visibleOffset = status.visibleOffset,\n        panels = status.panels;\n    var renderer = this._renderer;\n    var control = this._control; // Can't add/remove panels on external rendering\n\n    if (((_a = panels[0]) === null || _a === void 0 ? void 0 : _a.html) && !this._renderExternal) {\n      renderer.batchRemove({\n        index: 0,\n        deleteCount: this.panels.length,\n        hasDOMInElements: true\n      });\n      renderer.batchInsert({\n        index: 0,\n        elements: parseElement(panels.map(function (panel) {\n          return panel.html;\n        })),\n        hasDOMInElements: true\n      });\n    }\n\n    if (index) {\n      var panelIndex = visibleOffset ? index - visibleOffset : index;\n      void this.moveTo(panelIndex, 0).catch(function () {\n        return void 0;\n      });\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      var panel = position.panel,\n          progressInPanel = position.progressInPanel;\n      var panelIndex = visibleOffset ? panel - visibleOffset : panel;\n      var panelRange = renderer.panels[panelIndex].range;\n      var newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n      void control.moveToPosition(newCameraPos, 0).catch(function () {\n        return void 0;\n      });\n    }\n  };\n  /**\r\n   * Add plugins that can have different effects on Flicking\r\n   * @ko        \r\n   * @param {...Plugin} plugins The plugin(s) to add<ko> ()</ko>\r\n   * @return {this}\r\n   * @see https://github.com/naver/egjs-flicking-plugins\r\n   */\n\n\n  __proto.addPlugins = function () {\n    var _a;\n\n    var _this = this;\n\n    var plugins = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      plugins[_i] = arguments[_i];\n    }\n\n    if (this._initialized) {\n      plugins.forEach(function (item) {\n        return item.init(_this);\n      });\n    }\n\n    (_a = this._plugins).push.apply(_a, __spread(plugins));\n\n    return this;\n  };\n  /**\r\n   * Remove plugins from Flicking.\r\n   * @ko   .\r\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko> ().</ko>\r\n   * @return {this}\r\n   * @see https://github.com/naver/egjs-flicking-plugins\r\n   */\n\n\n  __proto.removePlugins = function () {\n    var _this = this;\n\n    var plugins = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      plugins[_i] = arguments[_i];\n    }\n\n    plugins.forEach(function (item) {\n      var foundIndex = findIndex(_this._plugins, function (val) {\n        return val === item;\n      });\n\n      if (foundIndex >= 0) {\n        item.destroy();\n\n        _this._plugins.splice(foundIndex, 1);\n      }\n    });\n    return this;\n  };\n  /**\r\n   * Update viewport/panel sizes\r\n   * @ko     \r\n   * @method\r\n   * @fires Flicking#beforeResize\r\n   * @fires Flicking#afterResize\r\n   * @return {this}\r\n   */\n\n\n  __proto.resize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var viewport, renderer, camera, control, activePanel, prevWidth, prevHeight, prevProgressInPanel, newWidth, newHeight, sizeChanged;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            viewport = this._viewport;\n            renderer = this._renderer;\n            camera = this._camera;\n            control = this._control;\n            activePanel = control.activePanel;\n            prevWidth = viewport.width;\n            prevHeight = viewport.height;\n            prevProgressInPanel = activePanel ? camera.getProgressInPanel(activePanel) : 0;\n            this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n              width: prevWidth,\n              height: prevHeight,\n              element: viewport.element\n            }));\n            viewport.resize();\n            return [4\n            /*yield*/\n            , renderer.forceRenderAllPanels()];\n\n          case 1:\n            _a.sent(); // Render all panel elements, to update sizes\n\n\n            renderer.updatePanelSize();\n            camera.updateAlignPos();\n            camera.updateRange();\n            camera.updateAnchors();\n            return [4\n            /*yield*/\n            , renderer.render()];\n\n          case 2:\n            _a.sent();\n\n            if (control.animating) ; else {\n              control.updatePosition(prevProgressInPanel);\n              control.updateInput();\n            }\n\n            newWidth = viewport.width;\n            newHeight = viewport.height;\n            sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n            this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n              width: viewport.width,\n              height: viewport.height,\n              prev: {\n                width: prevWidth,\n                height: prevHeight\n              },\n              sizeChanged: sizeChanged,\n              element: viewport.element\n            }));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add new panels after the last panel\r\n   * @ko       \r\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\r\n   * <ko> HTMLElement,   outerHTML,   </ko>\r\n   * @return {Panel[]} An array of appended panels<ko>  </ko>\r\n   * @see Panel\r\n   * @see ElementLike\r\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\r\n   * @example\r\n   * ```ts\r\n   * const flicking = new Flicking(\"#flick\");\r\n   * // These are possible parameters\r\n   * flicking.append(document.createElement(\"div\"));\r\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\r\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\r\n   * // Even this is possible\r\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\r\n   * ```\r\n   */\n\n\n  __proto.append = function (element) {\n    return this.insert(this._renderer.panelCount, element);\n  };\n  /**\r\n   * Add new panels before the first panel\r\n   * This will increase index of panels after by the number of panels added\r\n   * @ko    (index 0)   \r\n   *       .\r\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\r\n   * <ko> HTMLElement,   outerHTML,   </ko>\r\n   * @return {Panel[]} An array of prepended panels<ko>  </ko>\r\n   * @see Panel\r\n   * @see ElementLike\r\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\r\n   * @example\r\n   * ```ts\r\n   * const flicking = new eg.Flicking(\"#flick\");\r\n   * flicking.prepend(document.createElement(\"div\"));\r\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\r\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\r\n   * // Even this is possible\r\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\r\n   * ```\r\n   */\n\n\n  __proto.prepend = function (element) {\n    return this.insert(0, element);\n  };\n  /**\r\n   * Insert new panels at given index\r\n   * This will increase index of panels after by the number of panels added\r\n   * @ko     \r\n   *             .\r\n   * @param {number} index Index to insert new panels at<ko>   </ko>\r\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\r\n   * <ko> HTMLElement,   outerHTML,   </ko>\r\n   * @return {Panel[]} An array of prepended panels<ko>  </ko>\r\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\r\n   * @example\r\n   * ```ts\r\n   * const flicking = new eg.Flicking(\"#flick\");\r\n   * flicking.insert(0, document.createElement(\"div\"));\r\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\r\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\r\n   * // Even this is possible\r\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\r\n   * ```\r\n   */\n\n\n  __proto.insert = function (index, element) {\n    if (this._renderExternal) {\n      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({\n      index: index,\n      elements: parseElement(element),\n      hasDOMInElements: true\n    });\n  };\n  /**\r\n   * Remove the panel at the given index\r\n   * This will decrease index of panels after by the number of panels removed\r\n   * @ko    \r\n   *            \r\n   * @param {number} index Index of panel to remove<ko>  </ko>\r\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index`    </ko>\r\n   * @return {Panel[]} An array of removed panels<ko>  </ko>\r\n   */\n\n\n  __proto.remove = function (index, deleteCount) {\n    if (deleteCount === void 0) {\n      deleteCount = 1;\n    }\n\n    if (this._renderExternal) {\n      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({\n      index: index,\n      deleteCount: deleteCount,\n      hasDOMInElements: true\n    });\n  };\n\n  __proto._createControl = function () {\n    var _a;\n\n    var moveType = this._moveType;\n    var moveTypes = Object.keys(MOVE_TYPE).map(function (key) {\n      return MOVE_TYPE[key];\n    });\n    var moveTypeStr = Array.isArray(moveType) ? moveType[0] : moveType;\n    var moveTypeOptions = Array.isArray(moveType) ? (_a = moveType[1]) !== null && _a !== void 0 ? _a : {} : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl(moveTypeOptions);\n\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions);\n\n      case MOVE_TYPE.STRICT:\n        return new StrictControl(moveTypeOptions);\n    }\n  };\n\n  __proto._createCamera = function () {\n    if (this._circular && this._bound) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n    }\n\n    return new Camera({\n      align: this._align\n    });\n  };\n\n  __proto._createRenderer = function () {\n    var externalRenderer = this._externalRenderer;\n\n    if (this._virtual && this._panelsPerView <= 0) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"virtual\\\" and \\\"panelsPerView\\\" option should be used together, ignoring virtual.\");\n    }\n\n    return externalRenderer ? externalRenderer : this._renderExternal ? this._createExternalRenderer() : this._createVanillaRenderer();\n  };\n\n  __proto._createExternalRenderer = function () {\n    var _a = this._renderExternal,\n        renderer = _a.renderer,\n        rendererOptions = _a.rendererOptions;\n    return new renderer(__assign({\n      align: this._align\n    }, rendererOptions));\n  };\n\n  __proto._createVanillaRenderer = function () {\n    var virtual = this.virtualEnabled;\n    return new VanillaRenderer({\n      align: this._align,\n      strategy: virtual ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({\n        providerCtor: VanillaElementProvider\n      })\n    });\n  };\n\n  __proto._moveToInitialPanel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var renderer, control, initialPanel;\n      return __generator(this, function (_a) {\n        renderer = this._renderer;\n        control = this._control;\n        initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n        if (!initialPanel) return [2\n        /*return*/\n        ];\n        control.setActive(initialPanel, null, false);\n        return [2\n        /*return*/\n        , control.moveToPanel(initialPanel, {\n          duration: 0\n        })];\n      });\n    });\n  };\n  /**\r\n   * Version info string\r\n   * @ko  \r\n   * @type {string}\r\n   * @readonly\r\n   * @example\r\n   * ```ts\r\n   * Flicking.VERSION;  // ex) 4.0.0\r\n   * ```\r\n   */\n\n\n  Flicking.VERSION = \"4.5.0\";\n  return Flicking;\n}(Component);\n\n/**\r\n * Decorator that makes the method of flicking available in the framework.\r\n * @ko        .\r\n * @memberof eg.Flicking\r\n * @private\r\n * @example\r\n * ```js\r\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\r\n *\r\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\r\n *   &#64;withFlickingMethods\r\n *   private flicking: Flicking;\r\n * }\r\n * ```\r\n */\n\nvar withFlickingMethods = function (prototype, flickingName) {\n  [Component.prototype, Flicking.prototype].forEach(function (proto) {\n    Object.getOwnPropertyNames(proto).filter(function (name) {\n      return !prototype[name] && !name.startsWith(\"_\") && name !== \"constructor\";\n    }).forEach(function (name) {\n      var descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\n      if (descriptor.value) {\n        // Public Function\n        Object.defineProperty(prototype, name, {\n          value: function () {\n            var _a;\n\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return (_a = descriptor.value).call.apply(_a, __spread([this[flickingName]], args));\n          }\n        });\n      } else {\n        var getterDescriptor = {};\n\n        if (descriptor.get) {\n          getterDescriptor.get = function () {\n            var _a;\n\n            return (_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(this[flickingName]);\n          };\n        }\n\n        if (descriptor.set) {\n          getterDescriptor.set = function () {\n            var _a;\n\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spread([this[flickingName]], args));\n          };\n        }\n\n        Object.defineProperty(prototype, name, getterDescriptor);\n      }\n    });\n  });\n};\n\nvar sync = (function (flicking, diffResult, rendered) {\n  var renderer = flicking.renderer;\n  var panels = renderer.panels;\n\n  var prevList = __spread(diffResult.prevList);\n\n  if (diffResult.removed.length > 0) {\n    var endIdx_1 = -1;\n    var prevIdx_1 = -1;\n    diffResult.removed.forEach(function (removedIdx) {\n      if (endIdx_1 < 0) {\n        endIdx_1 = removedIdx;\n      }\n\n      if (prevIdx_1 >= 0 && removedIdx !== prevIdx_1 - 1) {\n        batchRemove(renderer, prevIdx_1, endIdx_1 + 1);\n        endIdx_1 = removedIdx;\n        prevIdx_1 = removedIdx;\n      } else {\n        prevIdx_1 = removedIdx;\n      }\n\n      prevList.splice(removedIdx, 1);\n    });\n    batchRemove(renderer, prevIdx_1, endIdx_1 + 1);\n  }\n\n  diffResult.ordered.forEach(function (_a) {\n    var _b = __read(_a, 2),\n        prevIdx = _b[0],\n        newIdx = _b[1];\n\n    var prevPanel = panels[prevIdx];\n    var indexDiff = newIdx - prevIdx;\n\n    if (indexDiff > 0) {\n      var middlePanels = panels.slice(prevIdx + 1, newIdx + 1);\n      prevPanel.increaseIndex(indexDiff);\n      middlePanels.forEach(function (panel) {\n        return panel.decreaseIndex(1);\n      });\n    } else {\n      var middlePanels = panels.slice(newIdx, prevIdx);\n      prevPanel.decreaseIndex(-indexDiff);\n      middlePanels.forEach(function (panel) {\n        return panel.increaseIndex(1);\n      });\n    } // Update position\n\n\n    prevPanel.resize();\n  });\n\n  if (diffResult.ordered.length > 0) {\n    panels.sort(function (panel1, panel2) {\n      return panel1.index - panel2.index;\n    });\n  }\n\n  if (diffResult.added.length > 0) {\n    var startIdx_1 = -1;\n    var prevIdx_2 = -1;\n    var addedElements_1 = rendered.slice(prevList.length);\n    diffResult.added.forEach(function (addedIdx, idx) {\n      if (startIdx_1 < 0) {\n        startIdx_1 = idx;\n      }\n\n      if (prevIdx_2 >= 0 && addedIdx !== prevIdx_2 + 1) {\n        batchInsert(renderer, diffResult, addedElements_1, startIdx_1, idx + 1);\n        startIdx_1 = -1;\n        prevIdx_2 = -1;\n      } else {\n        prevIdx_2 = addedIdx;\n      }\n    });\n\n    if (startIdx_1 >= 0) {\n      batchInsert(renderer, diffResult, addedElements_1, startIdx_1);\n    }\n  }\n});\n\nvar batchInsert = function (renderer, diffResult, addedElements, startIdx, endIdx) {\n  renderer.batchInsert.apply(renderer, __spread(diffResult.added.slice(startIdx, endIdx).map(function (index, elIdx) {\n    return {\n      index: index,\n      elements: [addedElements[elIdx]],\n      hasDOMInElements: false\n    };\n  })));\n};\n\nvar batchRemove = function (renderer, startIdx, endIdx) {\n  var removed = renderer.panels.slice(startIdx, endIdx);\n  renderer.batchRemove({\n    index: startIdx,\n    deleteCount: removed.length,\n    hasDOMInElements: false\n  });\n};\n\nvar getRenderingPanels = (function (flicking, diffResult) {\n  var removedPanels = diffResult.removed.reduce(function (map, idx) {\n    map[idx] = true;\n    return map;\n  }, {});\n  var maintainedMap = diffResult.maintained.reduce(function (map, _a) {\n    var _b = __read(_a, 2),\n        prev = _b[0],\n        current = _b[1];\n\n    map[prev] = current;\n    return map;\n  }, {});\n  return __spread(flicking.panels.filter(function (panel) {\n    return !removedPanels[panel.index];\n  }) // Sort panels by position\n  .sort(function (panel1, panel2) {\n    return panel1.position + panel1.offset - (panel2.position + panel2.offset);\n  }).map(function (panel) {\n    return diffResult.list[maintainedMap[panel.index]];\n  }), diffResult.added.map(function (idx) {\n    return diffResult.list[idx];\n  }));\n});\n\nvar getDefaultCameraTransform = (function (align, horizontal, firstPanelSize) {\n  if (align === void 0) {\n    align = ALIGN.CENTER;\n  }\n\n  if (horizontal === void 0) {\n    horizontal = true;\n  }\n\n  var cameraAlign = getCameraAlign(align);\n  var panelAlign = getPanelAlign(align);\n  if (panelAlign == null) return \"\";\n  var camPosition = \"calc(\" + cameraAlign + \" - (\" + (firstPanelSize || \"0px\") + \" * \" + panelAlign.percentage + \") - \" + panelAlign.absolute + \"px)\";\n  return horizontal ? \"translate(\" + camPosition + \")\" : \"translate(0, \" + camPosition + \")\";\n});\n\nvar getCameraAlign = function (align) {\n  var alignVal = typeof align === \"object\" ? align.camera : align;\n  return parseAlign(alignVal);\n};\n\nvar getPanelAlign = function (align) {\n  var alignVal = typeof align === \"object\" ? align.panel : align;\n  return parseArithmeticExpression(parseAlign(alignVal));\n};\n\nvar parseAlign = function (alignVal) {\n  if (typeof alignVal === \"number\") {\n    return alignVal + \"px\";\n  }\n\n  switch (alignVal) {\n    case ALIGN.CENTER:\n      return \"50%\";\n\n    case ALIGN.NEXT:\n      return \"100%\";\n\n    case ALIGN.PREV:\n      return \"0%\";\n\n    default:\n      return alignVal;\n  }\n};\n\n/*\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\nexport { ALIGN, AnchorPoint, AnimatingState, AxesController, BoundCameraMode, CIRCULAR_FALLBACK, CLASS, Camera, CircularCameraMode, Control, DIRECTION, DisabledState, DraggingState, CODE as ERROR_CODE, EVENTS, ExternalRenderer, FlickingError, FreeControl, HoldingState, IdleState, LinearCameraMode, MOVE_TYPE, NormalRenderingStrategy, Panel, Renderer, SnapControl, State, StateMachine, StrictControl, VanillaElementProvider, VanillaRenderer, Viewport, VirtualElementProvider, VirtualManager, VirtualPanel, VirtualRenderingStrategy, checkExistence, circulateIndex, circulatePosition, clamp, Flicking as default, find, findIndex, findRight, getDefaultCameraTransform, getDirection, getElement, getFlickingAttached, getMinusCompensatedIndex, getProgress, getRenderingPanels, getStyle, includes, isBetween, isString, merge, parseAlign$1 as parseAlign, parseArithmeticExpression, parseArithmeticSize, parseBounce, parseCSSSizeValue, parseElement, parsePanelAlign, range, setPrototypeOf, setSize, sync, toArray, withFlickingMethods };\n//# sourceMappingURL=flicking.esm.js.map\n"],"sourceRoot":""}